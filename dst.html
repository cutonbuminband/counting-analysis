<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>rcounting - Daylight Saving Time: On modelling and robustness</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title">Daylight Saving Time: On modelling and robustness</h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">rcounting</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle sidebar-tool" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">Analysis</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Analysing rcounting data</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./separators.html" class="sidebar-item-text sidebar-link">The use of separators</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./runs.html" class="sidebar-item-text sidebar-link">Longest runs</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./network.html" class="sidebar-item-text sidebar-link">The r/counting network</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./counting_counters.html" class="sidebar-item-text sidebar-link">Counting counters</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./time.html" class="sidebar-item-text sidebar-link">Tick tock: looking at counting activity over time</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./distribution.html" class="sidebar-item-text sidebar-link">The Distribution of Counts or: How I Learned to Stop Worrying and Love Pandas Indexing</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./dst.html" class="sidebar-item-text sidebar-link active">Daylight Saving Time: On modelling and robustness</a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./examples.html" class="sidebar-item-text sidebar-link">Examples</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#a-first-model" id="toc-a-first-model" class="nav-link active" data-scroll-target="#a-first-model">A first model</a></li>
  <li><a href="#validating-the-model" id="toc-validating-the-model" class="nav-link" data-scroll-target="#validating-the-model">Validating the model</a>
  <ul class="collapse">
  <li><a href="#adding-more-weeks" id="toc-adding-more-weeks" class="nav-link" data-scroll-target="#adding-more-weeks">Adding more weeks</a></li>
  <li><a href="#including-the-end-of-dst" id="toc-including-the-end-of-dst" class="nav-link" data-scroll-target="#including-the-end-of-dst">Including the end of DST</a></li>
  <li><a href="#summing-up" id="toc-summing-up" class="nav-link" data-scroll-target="#summing-up">Summing up</a></li>
  </ul></li>
  <li><a href="#more-advanced-models" id="toc-more-advanced-models" class="nav-link" data-scroll-target="#more-advanced-models">More Advanced Models</a>
  <ul class="collapse">
  <li><a href="#disaggregating-the-years" id="toc-disaggregating-the-years" class="nav-link" data-scroll-target="#disaggregating-the-years">Disaggregating the years</a></li>
  <li><a href="#disaggregating-the-different-counters" id="toc-disaggregating-the-different-counters" class="nav-link" data-scroll-target="#disaggregating-the-different-counters">Disaggregating the different counters</a></li>
  <li><a href="#looking-only-at-the-most-regular-counters" id="toc-looking-only-at-the-most-regular-counters" class="nav-link" data-scroll-target="#looking-only-at-the-most-regular-counters">Looking only at the most regular counters</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title d-none d-lg-block">Daylight Saving Time: On modelling and robustness</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>In a <a href="https://cutonbuminband.github.io/counting-analysis/time.html">previous post</a> I looked at the daily rhythm of <a href="http://www.reddit.com/r/counting">r/counting</a>, at what time of day the subreddit is most active, and how that has changed throughout the years. In this post I will try and answer the question that’s on nobody’s lips: Is it possible to see the effect of daylight saving time on the r/counting schedule?</p>
<p>Reddit stores the UTC timestamp for every count, so it’s possible to compare the counting activity just before the start of DST with the counting activity just afterwards, and see whether there’s a difference. If counts always follow the same pattern in local time, and all counters observe DST at the same time, then that should show up as a rigid shift in the data.</p>
<p>That’s the theory at least. As a spoiler, I’m doing something a bit different in this post, so it’s going to seem a lot more open-ended and exploratory than some of the other ones. When I started coding and writing I didn’t entirely know where I was going to end up, so you can think of this as going on a journey with me. Apart from answering the question, my goal with this post is to show you my general approach for dealing with these kinds of questions, and to highlight some of my thoughts along the way.</p>
<div class="page-columns page-full"><p>Before I can get started, there’s one more thing to get out of the way, namely the fact that DST occurs at different times (if at all) throughout the world. In this post, I’ve focussed exclusively on DST in the US &amp; Canada<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, where it starts on the second Sunday in March and ends on the first Sunday of November of each year<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p><div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;Apart from Hawaii and Arizona, which are weird</p></li><li id="fn2"><p><sup>2</sup>&nbsp;That hasn’t always been the DST rule, but it’s been the case for as long as r/c has existed</p></li></div></div>
<p>I’ll start off with some code to import the relevant packages and load the data.</p>
<div class="cell" data-execution_count="1">
<details>
<summary>Code for importing packages and loading data</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sqlite3</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> rcounting <span class="im">import</span> analysis, plots, units</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> rcounting.counters <span class="im">import</span> apply_alias</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> datetime <span class="im">import</span> datetime, timedelta</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> calendar <span class="im">import</span> timegm</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>sns.set_theme()</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>data_directory <span class="op">=</span> Path(<span class="st">"../data"</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>db <span class="op">=</span> sqlite3.<span class="ex">connect</span>(data_directory <span class="op">/</span> <span class="st">"counting.sqlite"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="a-first-model" class="level1">
<h1>A first model</h1>
<p>To see the effect of DST, I can compare the time of day plots for the weeks just before and just after DST is introduced, and see if there are any obvious differences. To maximise the effect of I’ll focus only on counts that occurred Monday to Friday, since people’s weekday schedules should generally be more regular than their weekends.</p>
<p>To start with, I’m going to need some code to find when DST starts and ends on any given year</p>
<div class="cell" data-execution_count="2">
<details open="">
<summary>Finding the start of DST for every year</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>days <span class="op">=</span> [<span class="st">"monday"</span>, <span class="st">"tuesday"</span>, <span class="st">"wednesday"</span>, <span class="st">"thursday"</span>, <span class="st">"friday"</span>, <span class="st">"saturday"</span>, <span class="st">"sunday"</span>]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_nth_weekday(year, month, weekday, n):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> datetime(year, month, <span class="dv">1</span> <span class="op">+</span> <span class="dv">7</span> <span class="op">*</span> (n <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">=</span> (days.index(weekday.lower()) <span class="op">-</span> d.weekday()) <span class="op">%</span> <span class="dv">7</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d <span class="op">+</span> timedelta(offset) <span class="op">+</span> timedelta(hours<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2012</span>, <span class="dv">2024</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>dst_start <span class="op">=</span> {</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    year: timegm(find_nth_weekday(year, <span class="dv">3</span>, <span class="st">"sunday"</span>, <span class="dv">2</span>).timetuple()) <span class="cf">for</span> year <span class="kw">in</span> years</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>dst_end <span class="op">=</span> {</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    year: timegm(find_nth_weekday(year, <span class="dv">11</span>, <span class="st">"sunday"</span>, <span class="dv">1</span>).timetuple()) <span class="cf">for</span> year <span class="kw">in</span> years</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>I’ll also define a bunch of constants that I’m going to need later.</p>
<div class="cell" data-execution_count="3">
<details>
<summary>Defining constants for later use</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>WEEK <span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">24</span> <span class="op">*</span> units.HOUR</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>OFFSET <span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> units.HOUR</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>BIN_WIDTH <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="bu">int</span>(units.DAY <span class="op">/</span> BIN_WIDTH)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>minval, maxval <span class="op">=</span> <span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>BIN_TO_MINUTE <span class="op">=</span> (BIN_WIDTH <span class="op">/</span> <span class="dv">60</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>time_axis <span class="op">=</span> np.linspace(<span class="dv">0</span>, units.DAY, nbins, endpoint<span class="op">=</span><span class="va">False</span>) <span class="op">+</span> BIN_WIDTH <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>dy <span class="op">=</span> <span class="fl">0.07</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>And finally I’ll define some code for getting the raw data into slightly more manageable shape, and to calculate a counting rate over time from the timestamps of each count.</p>
<div class="cell" data-execution_count="4">
<details open="">
<summary>Code for getting the raw data into slightly more manageable shape.</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> wrangle(data, week_map<span class="op">=</span>dst_start):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> data.reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"username"</span>] <span class="op">=</span> data[<span class="st">"username"</span>].<span class="bu">apply</span>(apply_alias)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"timestamp"</span>] <span class="op">=</span> data[<span class="st">"timestamp"</span>] <span class="op">-</span> OFFSET</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"date"</span>] <span class="op">=</span> pd.to_datetime(data[<span class="st">"timestamp"</span>], unit<span class="op">=</span><span class="st">"s"</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">'time'</span>] <span class="op">=</span> (data[<span class="st">'timestamp'</span>]) <span class="op">%</span> units.DAY</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"week"</span>] <span class="op">=</span> (np.floor((data[<span class="st">"timestamp"</span>]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>                              <span class="op">-</span> pd.to_datetime(data[<span class="st">"timestamp"</span>], unit<span class="op">=</span><span class="st">"s"</span>).dt.year.<span class="bu">map</span>(week_map))</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                             <span class="op">/</span> WEEK)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>                    .astype(<span class="bu">int</span>))</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"year"</span>] <span class="op">=</span> data[<span class="st">"date"</span>].dt.year</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_kdes(df):</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    n_weeks <span class="op">=</span> <span class="bu">len</span>(df[<span class="st">"week"</span>].unique())</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    kdes <span class="op">=</span> (df</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            .groupby(<span class="st">"week"</span>)[<span class="st">"time"</span>]</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            .<span class="bu">apply</span>(<span class="kw">lambda</span> x: pd.Series(analysis.fft_kde(</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>                x,</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>                nbins,</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>                kernel<span class="op">=</span><span class="st">"normal_distribution"</span>,</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>                sigma<span class="op">=</span><span class="fl">0.02</span>)[<span class="dv">1</span>] <span class="op">*</span> nbins))</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>            .reset_index()[[<span class="st">"week"</span>, <span class="st">"time"</span>]])</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    kdes[<span class="st">"time_axis"</span>] <span class="op">=</span> np.hstack(n_weeks<span class="op">*</span>[time_axis])</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    kdes.columns <span class="op">=</span> [<span class="st">"week"</span>, <span class="st">"rate"</span>, <span class="st">"time"</span>]</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> kdes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>With that out of the way, I’ll select the weeks just before the start of DST and the weeks just after the end of DST for every year in r/counting’s history. Then, I can plot the distribution of counts throughout the day for the week before and the week after the introduction of DST, and see how they differ:</p>
<div class="cell" data-execution_count="5">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> query(x):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="ss">f"select timestamp, username from comments where timestamp between "</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>            <span class="ss">f"</span><span class="sc">{</span>x <span class="op">+</span> OFFSET <span class="op">+</span> minval <span class="op">*</span> WEEK<span class="sc">}</span><span class="ss"> and </span><span class="sc">{</span>x <span class="op">+</span> OFFSET <span class="op">+</span> maxval <span class="op">*</span> WEEK<span class="sc">}</span><span class="ss"> "</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>            <span class="ss">f"order by timestamp"</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>spring_all <span class="op">=</span> wrangle(pd.concat([pd.read_sql(query(x), db) <span class="cf">for</span> x <span class="kw">in</span> dst_start.values()]))</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mask(df):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ((df[<span class="st">"date"</span>].dt.weekday <span class="op">&lt;</span> <span class="dv">5</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">&amp;</span> (<span class="op">-</span><span class="dv">2</span> <span class="op">&lt;=</span> df[<span class="st">"week"</span>])</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">&amp;</span> (df[<span class="st">"week"</span>] <span class="op">&lt;</span> <span class="dv">2</span>))</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>spring <span class="op">=</span> spring_all[mask(spring_all)].copy()</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>spring_kdes <span class="op">=</span> generate_kdes(spring)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>week_map <span class="op">=</span> {<span class="op">-</span><span class="dv">2</span>: <span class="st">"Control without DST"</span>,</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">-</span><span class="dv">1</span>: <span class="st">"Without DST"</span>,</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            <span class="dv">0</span>: <span class="st">"With DST"</span>,</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>            <span class="dv">1</span>: <span class="st">"Control with DST"</span>}</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>spring_kdes[<span class="st">"week_name"</span>] <span class="op">=</span> spring_kdes[<span class="st">"week"</span>].<span class="bu">map</span>(week_map)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> week <span class="kw">in</span> [<span class="st">"With DST"</span>, <span class="st">"Without DST"</span>]:</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> spring_kdes.query(<span class="st">"week_name == @week"</span>)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    plt.fill_between(df[<span class="st">"time"</span>], df[<span class="st">"rate"</span>], alpha<span class="op">=</span><span class="fl">0.8</span>, label<span class="op">=</span>week)</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.gca()</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>plots.make_time_axis(ax)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Counting rate (arbitrary units)"</span>)</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Time of Day (UTC - 5)"</span>)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="dst_files/figure-html/cell-6-output-1.png" width="627" height="436"></p>
</div>
</div>
<p>The shape of the two plots is similar, and it looks like the plot with DST is generally leading the one without, as would be expected if one was just a rigid shift of the other. But it’s certainly not a perfect match, and it’s hard to see from the curves just how much the DST curve is leading.</p>
<p>I can try and see what the optimal shift of the DST curve would be to get it to match the curve without DST.</p>
<div class="cell" data-execution_count="6">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_shifted_overlap(df, week1, week2):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    fixed <span class="op">=</span> df.loc[df[<span class="st">"week_name"</span>] <span class="op">==</span> week2, <span class="st">"rate"</span>].to_numpy()</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    rotating <span class="op">=</span> df.loc[df[<span class="st">"week_name"</span>] <span class="op">==</span> week1, <span class="st">"rate"</span>].to_numpy()</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    norm <span class="op">=</span> np.trapz(fixed <span class="op">*</span> rotating, x<span class="op">=</span>time_axis)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    shifts <span class="op">=</span> [np.trapz(fixed <span class="op">*</span> np.roll(rotating, i), x<span class="op">=</span>time_axis) <span class="op">/</span> norm <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(fixed))]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    optimal_shift <span class="op">=</span> (np.argmax(shifts) <span class="op">+</span> nbins <span class="op">/</span> <span class="dv">2</span>) <span class="op">%</span> nbins <span class="op">-</span> nbins<span class="op">/</span><span class="dv">2</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> shifts, optimal_shift</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>shifts, optimal_shift <span class="op">=</span> calculate_shifted_overlap(spring_kdes, <span class="st">"With DST"</span>,<span class="st">"Without DST"</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>plt.plot(shifts)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>, <span class="bu">len</span>(shifts))</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.gca()</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>ticks, labels <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>[(x <span class="op">*</span> <span class="dv">120</span>, <span class="ss">f"</span><span class="sc">{</span>x<span class="sc">:02d}</span><span class="ss">:00"</span>) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">25</span>, <span class="dv">3</span>)])</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>ax.set_xticks(ticks)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>ax.set_xticklabels(labels)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The optimal shift is </span><span class="sc">{</span><span class="bu">int</span>(optimal_shift <span class="op">*</span> BIN_TO_MINUTE)<span class="sc">}</span><span class="ss"> minutes."</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Shift (hours)"</span>)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Similarity score"</span>)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The optimal shift is 45 minutes.</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="dst_files/figure-html/cell-7-output-2.png" width="627" height="437"></p>
</div>
</div>
<p>That’s a bit less than one hour, but it’s still suggestive. Apparently it <em>is</em> possoible to use the counting data to determine whether or not DST is currently active.</p>
<p>So, case closed, right?</p>
</section>
<section id="validating-the-model" class="level1">
<h1>Validating the model</h1>
<p>Not so fast.</p>
<p>It could be that there’s a shift of one hour every week and DST has nothing to do with it! More seriously, there are other changes happening throughout the time period apart from DST; in the spring the days are getting longer, particularly the evenings, and maybe that’s what’s driving the change. And I haven’t at all looked at what happens when the clocks go back.</p>
<section id="adding-more-weeks" class="level2">
<h2 class="anchored" data-anchor-id="adding-more-weeks">Adding more weeks</h2>
<p>Let’s start by looking at what happens before DST is active. For the preceding analysis to be valid, the distribution of counts throughout the day would need to be basically the same in the two weeks before the start of DST.</p>
<div class="cell" data-execution_count="7">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> week <span class="kw">in</span> [<span class="st">"Without DST"</span>, <span class="st">"Control without DST"</span>]:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> spring_kdes.query(<span class="st">"week_name == @week"</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    plt.fill_between(df[<span class="st">"time"</span>], df[<span class="st">"rate"</span>], alpha<span class="op">=</span><span class="fl">0.8</span>, label<span class="op">=</span>week)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.gca()</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>plots.make_time_axis(ax)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Counting rate (arbitrary units)"</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Time of Day (UTC - 5)"</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="dst_files/figure-html/cell-8-output-1.png" width="627" height="436"></p>
</div>
</div>
<p>Hm. Those two curves might be slightly more aligned than the two with and without DST, but it’s not super clear. I can check the optimal shift</p>
<div class="cell" data-execution_count="8">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>_, optimal_shift <span class="op">=</span> calculate_shifted_overlap(spring_kdes, <span class="st">"Without DST"</span>, <span class="st">"Control without DST"</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The optimal shift is </span><span class="sc">{</span><span class="bu">int</span>(optimal_shift <span class="op">*</span> BIN_TO_MINUTE)<span class="sc">}</span><span class="ss"> minutes."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The optimal shift is 98 minutes.</code></pre>
</div>
</div>
<p>That’s an even bigger shift than the one that happened when DST was introduced! I can plot the four curves for the two weeks before and after DST together and see if there’s any obvious pattern.</p>
<div class="cell" data-execution_count="9">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>spring_kdes[<span class="st">"shifted_rate"</span>] <span class="op">=</span> spring_kdes[<span class="st">"rate"</span>] <span class="op">+</span> (spring_kdes[<span class="st">"week"</span>] <span class="op">+</span> <span class="dv">2</span>) <span class="op">*</span> dy</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.lineplot(spring_kdes, x<span class="op">=</span><span class="st">"time"</span>, y<span class="op">=</span><span class="st">"shifted_rate"</span>, hue<span class="op">=</span><span class="st">"week_name"</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>ax.legend_.set_title(<span class="st">"Week"</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>plots.make_time_axis(ax)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">"upper center"</span>, ncol<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Counting rate (arbitrary units)"</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Time of Day (UTC - 5)"</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="dv">0</span>, <span class="fl">0.34</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="dst_files/figure-html/cell-10-output-1.png" width="627" height="436"></p>
</div>
</div>
<p>If you didn’t have the legend, would you be able to tell which two of these curves were with DST and which were without? It seems that the variation from week to week is so big that any DST signal that might be present in the data is just swamped by all the noise.</p>
</section>
<section id="including-the-end-of-dst" class="level2">
<h2 class="anchored" data-anchor-id="including-the-end-of-dst">Including the end of DST</h2>
<p>I can try and see if including the data for the end of DST makes any difference</p>
<div class="cell" data-execution_count="10">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>autumn_all <span class="op">=</span> wrangle(pd.concat([pd.read_sql(query(x), db) <span class="cf">for</span> x <span class="kw">in</span> dst_end.values()]), dst_end)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>autumn <span class="op">=</span> autumn_all[mask(autumn_all)].copy()</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>autumn[<span class="st">"week"</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span> <span class="op">-</span> autumn_all[<span class="st">"week"</span>]</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>kdes <span class="op">=</span> generate_kdes(pd.concat([spring, autumn]))</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>kdes[<span class="st">"week_name"</span>] <span class="op">=</span> kdes[<span class="st">"week"</span>].<span class="bu">map</span>(week_map)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>kdes[<span class="st">"shifted_rate"</span>] <span class="op">=</span> kdes[<span class="st">"rate"</span>] <span class="op">+</span> (kdes[<span class="st">"week"</span>] <span class="op">+</span> <span class="dv">2</span>) <span class="op">*</span> dy</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.lineplot(kdes, x<span class="op">=</span><span class="st">"time"</span>, y<span class="op">=</span><span class="st">"shifted_rate"</span>, hue<span class="op">=</span><span class="st">"week_name"</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>ax.legend_.set_title(<span class="st">"Week"</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>plots.make_time_axis(ax)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">"upper center"</span>, ncol<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Counting rate (arbitrary units)"</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Time of Day (UTC - 5)"</span>)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="dv">0</span>, <span class="fl">0.34</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>_, optimal_shift <span class="op">=</span> calculate_shifted_overlap(kdes, <span class="st">"With DST"</span>, <span class="st">"Without DST"</span>)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The optimal shift is </span><span class="sc">{</span><span class="bu">int</span>(optimal_shift <span class="op">*</span> BIN_TO_MINUTE)<span class="sc">}</span><span class="ss"> minutes."</span>)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The optimal shift is 17 minutes.</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-autumn-kdes" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="dst_files/figure-html/fig-autumn-kdes-output-2.png" width="582" height="436" class="figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;1: The aggregated activity on r/counting in the two weeks on either side of the start/end of DST.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>As before – would you be able to tell which of these graphs were with DST and which were without if you didn’t have the legend?</p>
</section>
<section id="summing-up" class="level2">
<h2 class="anchored" data-anchor-id="summing-up">Summing up</h2>
<p>The validation of the model has revealed that the activity on r/counting varies enough on a week to week basis that my initial assumptions are incorrect, and I can’t just treat the activity as a constant background with a DST signal on top. If I want to see the effect of DST, I’m going to have to come up with something more clever.</p>
</section>
</section>
<section id="more-advanced-models" class="level1 page-columns page-full">
<h1>More Advanced Models</h1>
<section id="disaggregating-the-years" class="level2">
<h2 class="anchored" data-anchor-id="disaggregating-the-years">Disaggregating the years</h2>
<p>What I did in the previous section was to aggregate the activity on r/counting across all the years it’s been active. After that, I honed in on specific weeks near the time of year when the clocks change, and asked if there was a rigid shift in the data.</p>
<p>This analysis revealed that the activity on r/counting isn’t stable over time. Maybe I’m losing information by aggregating all the years, and the signal would be clearer if I looked at each year separately.</p>
<p>Before I can make these comparisons I’m going to need a way of boiling down the information. <a href="#fig-autumn-kdes">Figure&nbsp;1</a> and friends in the previous section showed that spotting the shift by eye is very difficult, and if the plot is further split into a new line for each year, it’s going to become completely unreadable.</p>
<p>What I need is a way of compressing each (week, year) pair to a single point, so that the plots are still legible even after disaggregating the years.</p>
<p>I can use the fac t that the DST offset is exactly one hour to accomplish just this: For each week, I can calculate how much the distribution resembles that of the week before, and I can also calculate how much the distribution resembles the 1 hour <em>shifted</em> distribution from the week before.</p>
<p>For most of the year, it should be the case that the unshifted distribution is more similar then the shifted distribution. But, for the week where the clocks change, the shifted distribution should be more similar. So, I can calculate the similarity of the lagged and shifted distribution, and subtract the similarity of just the lagged distribution, and I have a DST fingerprint. For most weeks, it should give a negative value, but for the week where the clocks change it should give a positive value.</p>
<p>Let’s see how it goes!</p>
<div class="cell" data-execution_count="11">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dst_fingerprint(df, period<span class="op">=</span><span class="st">"spring"</span>):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate the dst fingerprint for a single year"""</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    transitions <span class="op">=</span> dst_start <span class="cf">if</span> period <span class="op">==</span> <span class="st">"spring"</span> <span class="cf">else</span> dst_end</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> df.resample(<span class="st">"300s"</span>, on<span class="op">=</span><span class="st">"date"</span>).size()</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    rates <span class="op">=</span> x.div(x.groupby(pd.Grouper(freq<span class="op">=</span><span class="st">"1d"</span>)).transform(<span class="st">"sum"</span>)).to_frame(name<span class="op">=</span><span class="st">"rate"</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    rates.index <span class="op">=</span> rates.index <span class="op">-</span> pd.to_datetime(rates.index.year.<span class="bu">map</span>(transitions), unit<span class="op">=</span><span class="st">"s"</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    shifted <span class="op">=</span> rates.shift(freq<span class="op">=</span><span class="st">"7d"</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    shift <span class="op">=</span> <span class="st">"-1h"</span> <span class="cf">if</span> period <span class="op">==</span> <span class="st">"spring"</span> <span class="cf">else</span> <span class="st">"1h"</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    dst_shifted <span class="op">=</span> shifted.shift(freq<span class="op">=</span>shift)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    dfs <span class="op">=</span> []</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> df <span class="kw">in</span> [shifted, dst_shifted]:</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        background <span class="op">=</span> pd.Series((maxval <span class="op">-</span> minval) <span class="op">*</span> [np.nan], <span class="bu">range</span>(minval, maxval), name<span class="op">=</span><span class="st">"delta"</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>        background.index.name <span class="op">=</span> <span class="st">"date"</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>        f1 <span class="op">=</span> pd.merge(rates, df, left_index<span class="op">=</span><span class="va">True</span>, right_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(f1) <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>            f1[<span class="st">"delta"</span>] <span class="op">=</span> (f1[<span class="st">"rate_x"</span>] <span class="op">-</span> f1[<span class="st">"rate_y"</span>]) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>            series <span class="op">=</span> f1.groupby(f1.index.days <span class="op">//</span> <span class="dv">7</span>)[<span class="st">"delta"</span>].<span class="bu">sum</span>()</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>            background.loc[series.index] <span class="op">=</span> series</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>        dfs.append(background)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dfs[<span class="dv">1</span>] <span class="op">-</span> dfs[<span class="dv">0</span>]</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multiple_dst_fingerprints(df, period<span class="op">=</span><span class="st">"spring"</span>):</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    groups <span class="op">=</span> df.groupby(<span class="st">"year"</span>).<span class="bu">apply</span>(dst_fingerprint, period<span class="op">=</span>period)</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> groups.reset_index().melt(id_vars<span class="op">=</span><span class="st">"year"</span>)</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>week_norm <span class="op">=</span> spring_all.groupby([<span class="st">"year"</span>, <span class="st">"username"</span>]).size() <span class="op">/</span> spring_all.groupby(<span class="st">"year"</span>).size()</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>year_norm <span class="op">=</span> spring_all.groupby(<span class="st">"year"</span>).size() <span class="op">/</span> <span class="bu">len</span>(spring_all)</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> multiple_dst_fingerprints(spring_all)</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(df, x<span class="op">=</span><span class="st">"date"</span>, y<span class="op">=</span><span class="st">"value"</span>, hue<span class="op">=</span><span class="st">"year"</span>, palette<span class="op">=</span><span class="st">"plasma"</span>)</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>sns.lineplot(</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>    df.dropna().set_index([<span class="st">"year"</span>, <span class="st">"date"</span>])[<span class="st">"value"</span>].mul(year_norm).groupby(level<span class="op">=</span><span class="dv">1</span>).<span class="bu">sum</span>(),</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"0.4"</span>,</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>    legend<span class="op">=</span><span class="va">False</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"0.5"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Weeks after start of DST"</span>)</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"DST fingerprint"</span>)</span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="dst_files/figure-html/cell-12-output-1.png" width="618" height="436"></p>
</div>
</div>
<p>Hm. This isn’t very promising. The DST signal should show up in this plot in the fact that the points at 0 should lie significantly higher than all the others. That’s not the case at all.</p>
<p>I can do the same thing for when DST ends, just for good measure, to see if the signal shows up there:</p>
<div class="cell" data-execution_count="12">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> multiple_dst_fingerprints(autumn_all, <span class="st">"autumn"</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(df, x<span class="op">=</span><span class="st">"date"</span>, y<span class="op">=</span><span class="st">"value"</span>, hue<span class="op">=</span><span class="st">"year"</span>, palette<span class="op">=</span><span class="st">"plasma"</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>sns.lineplot(</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    df.dropna().set_index([<span class="st">"year"</span>, <span class="st">"date"</span>])[<span class="st">"value"</span>].mul(year_norm).groupby(level<span class="op">=</span><span class="dv">1</span>).<span class="bu">sum</span>(),</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"0.4"</span>,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    legend<span class="op">=</span><span class="va">False</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"0.5"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Weeks after end of DST"</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"DST fingerprint"</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="dst_files/figure-html/cell-13-output-1.png" width="618" height="436"></p>
</div>
</div>
<p>Unfortunately, that didn’t seem to show the signal either. Before giving up completely and abandoning this as a fool’s errand, there’s one or two more things I can try.</p>
</section>
<section id="disaggregating-the-different-counters" class="level2">
<h2 class="anchored" data-anchor-id="disaggregating-the-different-counters">Disaggregating the different counters</h2>
<p>Regulars of r/counting will know that it’s not the same people who count every week. If proof of this is needed, you can take a look at the top weekly counters list and see that it really isn’t just a repeat from week to week. Perhaps this is one cause of the lack of pattern in the counting times. It’s certainly possible to imagine a world where counters are perfectly regular, but the different schedules of different counters coupled with their different activity from week to week adds up to a huge mess.</p>
<p>So I can keep going with the disaggregation, and see if I get a clearer signal when we compare the activity of individual counters from week to week.</p>
<div class="cell" data-execution_count="13">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> username_fingerprint(df, period<span class="op">=</span><span class="st">"spring"</span>):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    fingerprint <span class="op">=</span> (df.groupby([<span class="st">"year"</span>, <span class="st">"username"</span>])</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>                   .<span class="bu">apply</span>(dst_fingerprint, period<span class="op">=</span>period)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>                   .reset_index()</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>                   .melt(id_vars<span class="op">=</span>[<span class="st">"year"</span>, <span class="st">"username"</span>], var_name<span class="op">=</span><span class="st">"week"</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>                   .set_index([<span class="st">"year"</span>, <span class="st">"username"</span>, <span class="st">"week"</span>])[<span class="st">"value"</span>])</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fingerprint</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>fingerprints <span class="op">=</span> username_fingerprint(spring_all)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> (</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    fingerprints.dropna()</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    .mul(week_norm)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    .groupby(level<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">2</span>])</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    .<span class="bu">sum</span>()</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    .reset_index(name<span class="op">=</span><span class="st">"fingerprint"</span>)</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(df, x<span class="op">=</span><span class="st">"week"</span>, y<span class="op">=</span><span class="st">"fingerprint"</span>, hue<span class="op">=</span><span class="st">"year"</span>, palette<span class="op">=</span><span class="st">"plasma"</span>)</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>sns.lineplot(</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    df.set_index([<span class="st">"year"</span>, <span class="st">"week"</span>])[<span class="st">"fingerprint"</span>].mul(year_norm).groupby(level<span class="op">=</span><span class="dv">1</span>).<span class="bu">sum</span>(),</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    ax<span class="op">=</span>ax,</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"0.4"</span>,</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    legend<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"0.5"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Weeks after start of DST"</span>)</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"DST fingerprint"</span>)</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="dst_files/figure-html/cell-14-output-1.png" width="628" height="436"></p>
</div>
</div>
<p>Looking at this graph almost makes me think I have a sign error in the way I’ve defined the DST fingerprint. I’ve double checked, and I don’t think it’s the case, but this certainly isn’t the peak at 0 I was hoping to see.</p>
</section>
<section id="looking-only-at-the-most-regular-counters" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="looking-only-at-the-most-regular-counters">Looking only at the most regular counters</h2>
<p>None of what I’ve tried so far has seemed to work. There’s one last thing I can try: I can find out which counters were most regular in the period leading up to the start of DST each year, and only include them in the calculations</p>
<p>To do that I’ll need to slightly rework the code from <span class="spurious-link" target="A first model"><em>Section 1</em></span> for calculating the overlap between two different counting distributions. This will let me calculate the overlap for every counter for every year in the weeks around the onset of DST.</p>
<p>Then it’s just a bit of fidding with indices to find the 5 most regular counters two weeks before the start of DST for every year.</p>
<div class="cell" data-execution_count="14">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> similarity_score(df):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    kdes <span class="op">=</span> generate_kdes(df)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    groups <span class="op">=</span> kdes.groupby(<span class="st">"week"</span>)[<span class="st">"rate"</span>]</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    norm <span class="op">=</span> groups.transform(np.linalg.norm)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    kdes[<span class="st">"rate"</span>] <span class="op">/=</span> norm</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    overlaps <span class="op">=</span> (</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        (kdes.set_index([<span class="st">"week"</span>, <span class="st">"time"</span>]).groupby(<span class="st">"time"</span>)[<span class="st">"rate"</span>].diff() <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        .groupby(level<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        .<span class="bu">sum</span>()</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">-</span> overlaps <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>scores <span class="op">=</span> spring_all.groupby([<span class="st">"year"</span>, <span class="st">"username"</span>]).<span class="bu">apply</span>(similarity_score)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>scores <span class="op">=</span> scores[scores <span class="op">!=</span> <span class="dv">1</span>]</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>counters <span class="op">=</span> (</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    scores</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    .reset_index()</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    .query(<span class="st">"week== -2"</span>)</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    .sort_values([<span class="st">"year"</span>, <span class="st">"rate"</span>], ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    .groupby(<span class="st">"year"</span>)</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    .head(<span class="dv">5</span>)</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    .set_index([<span class="st">"year"</span>, <span class="st">"username"</span>])</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    .index</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>subset <span class="op">=</span> spring_all.set_index([<span class="st">"year"</span>, <span class="st">"username"</span>]).loc[counters]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>With that out of the way, I can plot the average similarity score for each year and week</p>
<div class="cell" data-execution_count="15">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>week_norm <span class="op">=</span> subset.groupby([<span class="st">"year"</span>, <span class="st">"username"</span>]).size() <span class="op">/</span> subset.groupby(<span class="st">"year"</span>).size()</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>year_norm <span class="op">=</span> subset.groupby(<span class="st">"year"</span>).size() <span class="op">/</span> <span class="bu">len</span>(subset)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>similarity <span class="op">=</span> (</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    scores.reset_index(level<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    .loc[counters]</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    .set_index(<span class="st">"week"</span>, append<span class="op">=</span><span class="va">True</span>)[<span class="st">"rate"</span>]</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    .mul(week_norm)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    .groupby(level<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">2</span>])</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    .<span class="bu">sum</span>()</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    .reset_index(name<span class="op">=</span><span class="st">"similarity"</span>)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(similarity, x<span class="op">=</span><span class="st">"week"</span>, y<span class="op">=</span><span class="st">"similarity"</span>, hue<span class="op">=</span><span class="st">"year"</span>, palette<span class="op">=</span><span class="st">"plasma"</span>)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>sns.lineplot(</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        similarity.set_index([<span class="st">"year"</span>, <span class="st">"week"</span>])[<span class="st">"similarity"</span>]</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        .mul(year_norm)</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>        .groupby(<span class="st">"week"</span>)</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>        .<span class="bu">sum</span>()</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"0.4"</span>,</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    ax<span class="op">=</span>ax,</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    legend<span class="op">=</span><span class="va">False</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Weeks after start of DST"</span>)</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Week consistency score"</span>)</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="dst_files/figure-html/cell-16-output-1.png" width="597" height="436"></p>
</div>
</div>
<div class="page-columns page-full"><p>I’ve decided to work with the consistency score rather than the DST fingerprint<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, because I wanted to highlight the effect of the selection I’ve made. You can see on the graph that the score two weeks before the start of DST is signficantly higher than all the other weeks, and in particular the least consistent year for week -2 is much more consistent tht the least consistent year for all the other weeks.</p><div class="no-row-height column-margin column-container"><li id="fn3"><p><sup>3</sup>&nbsp;The two scores behave similarly, with the exception that for the consistency score, we’d expected DST to show up as a dip at zero, rather than a peak.</p></li></div></div>
<p>This apparent result is just an artefact of the way I’ve selected the data: I’ve limited my search to people who were very consistent two weeks before the onset of DST, so it’s no surprise that the consistency is high here. The fact that the consistency is lower in the following weeks is due to a regression towards the mean.</p>
<p>That statistical artefact aside, it doesn’t seem that this analysis has brought me any closer to finding a clear sign of DST in the counting data. With the consistency score, the sign of DST is a dip at 0, so the fact that the least consistent week is the week DST starts is suggestive. But it’s not what I’d call proof.</p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>If you want to find out whether or not the US currently has DST, then looking at the comments on r/counting is not a viable method for doing so. I would suggest just googling it instead.</p>
<p>This post ended up being much longer than expected (and a fair bit longer than the reddit comment that it’s based on), mainly because I’ve had to change the conclusion along the way.</p>
<p>In the original, and in my first draft, I wasn’t as thorough with my robustness analysis as I’ve been here. That meant that I was more convinced by the hints of a DST signal in the data, and the conclusion reflected that. Unfortunately, this post has demonstrated that it just isn’t there. On the positive side, the post has also demonstrated the value of checking assumptions, validating any model that you might come up with, and generally having a healthy dose of skepticism towards any new discoveries – especially your own.</p>
<p>And that’s perhaps as good a place as any to end.</p>
<p>Until next time!</p>


<!-- -->

</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb19" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Daylight Saving Time: On modelling and robustness"</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>In a <span class="co">[</span><span class="ot">previous post</span><span class="co">](https://cutonbuminband.github.io/counting-analysis/time.html)</span> I looked at the daily rhythm of <span class="co">[</span><span class="ot">r/counting</span><span class="co">](http://www.reddit.com/r/counting)</span>, at what time of day the subreddit is most active, and how that has changed throughout the years. In this post I will try and answer the question that's on nobody's lips: Is it possible to see the effect of daylight saving time on the r/counting schedule?</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>Reddit stores the UTC timestamp for every count, so it's possible to compare the counting activity just before the start of DST with the counting activity just afterwards, and see whether there's a difference. If counts always follow the same pattern in local time, and all counters observe DST at the same time, then that should show up as a rigid shift in the data.</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>That's the theory at least. As a spoiler, I'm doing something a bit different in this post, so it's going to seem a lot more open-ended and exploratory than some of the other ones. When I started coding and writing I didn't entirely know where I was going to end up, so you can think of this as going on a journey with me. Apart from answering the question, my goal with this post is to show you my general approach for dealing with these kinds of questions, and to highlight some of my thoughts along the way.</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>Before I can get started, there's one more thing to get out of the way, namely the fact that DST occurs at different times (if at all) throughout the world. In this post, I've focussed exclusively on DST in the US &amp; Canada<span class="ot">[^1]</span>, where it starts on the second Sunday in March and ends on the first Sunday of November of each year<span class="ot">[^2]</span>.</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>I'll start off with some code to import the relevant packages and load the data.</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Code for importing packages and loading data"</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sqlite3</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> rcounting <span class="im">import</span> analysis, plots, units</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> rcounting.counters <span class="im">import</span> apply_alias</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> datetime <span class="im">import</span> datetime, timedelta</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> calendar <span class="im">import</span> timegm</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>sns.set_theme()</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>data_directory <span class="op">=</span> Path(<span class="st">"../data"</span>)</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>db <span class="op">=</span> sqlite3.<span class="ex">connect</span>(data_directory <span class="op">/</span> <span class="st">"counting.sqlite"</span>)</span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a><span class="fu"># A first model</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>To see the effect of DST, I can compare the time of day plots for the weeks just before and just after DST is introduced, and see if there are any obvious differences. To maximise the effect of I'll focus only on counts that occurred Monday to Friday, since people's weekday schedules should generally be more regular than their weekends.</span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>To start with, I'm going to need some code to find when DST starts and ends on any given year</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Finding the start of DST for every year"</span></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>days <span class="op">=</span> [<span class="st">"monday"</span>, <span class="st">"tuesday"</span>, <span class="st">"wednesday"</span>, <span class="st">"thursday"</span>, <span class="st">"friday"</span>, <span class="st">"saturday"</span>, <span class="st">"sunday"</span>]</span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_nth_weekday(year, month, weekday, n):</span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> datetime(year, month, <span class="dv">1</span> <span class="op">+</span> <span class="dv">7</span> <span class="op">*</span> (n <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">=</span> (days.index(weekday.lower()) <span class="op">-</span> d.weekday()) <span class="op">%</span> <span class="dv">7</span></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d <span class="op">+</span> timedelta(offset) <span class="op">+</span> timedelta(hours<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2012</span>, <span class="dv">2024</span>)</span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>dst_start <span class="op">=</span> {</span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a>    year: timegm(find_nth_weekday(year, <span class="dv">3</span>, <span class="st">"sunday"</span>, <span class="dv">2</span>).timetuple()) <span class="cf">for</span> year <span class="kw">in</span> years</span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a>dst_end <span class="op">=</span> {</span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a>    year: timegm(find_nth_weekday(year, <span class="dv">11</span>, <span class="st">"sunday"</span>, <span class="dv">1</span>).timetuple()) <span class="cf">for</span> year <span class="kw">in</span> years</span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-63"><a href="#cb19-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-64"><a href="#cb19-64" aria-hidden="true" tabindex="-1"></a>I'll also define a bunch of constants that I'm going to need later.</span>
<span id="cb19-65"><a href="#cb19-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-68"><a href="#cb19-68" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-69"><a href="#cb19-69" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb19-70"><a href="#cb19-70" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Defining constants for later use"</span></span>
<span id="cb19-71"><a href="#cb19-71" aria-hidden="true" tabindex="-1"></a>WEEK <span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">24</span> <span class="op">*</span> units.HOUR</span>
<span id="cb19-72"><a href="#cb19-72" aria-hidden="true" tabindex="-1"></a>OFFSET <span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> units.HOUR</span>
<span id="cb19-73"><a href="#cb19-73" aria-hidden="true" tabindex="-1"></a>BIN_WIDTH <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb19-74"><a href="#cb19-74" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="bu">int</span>(units.DAY <span class="op">/</span> BIN_WIDTH)</span>
<span id="cb19-75"><a href="#cb19-75" aria-hidden="true" tabindex="-1"></a>minval, maxval <span class="op">=</span> <span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span></span>
<span id="cb19-76"><a href="#cb19-76" aria-hidden="true" tabindex="-1"></a>BIN_TO_MINUTE <span class="op">=</span> (BIN_WIDTH <span class="op">/</span> <span class="dv">60</span>)</span>
<span id="cb19-77"><a href="#cb19-77" aria-hidden="true" tabindex="-1"></a>time_axis <span class="op">=</span> np.linspace(<span class="dv">0</span>, units.DAY, nbins, endpoint<span class="op">=</span><span class="va">False</span>) <span class="op">+</span> BIN_WIDTH <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb19-78"><a href="#cb19-78" aria-hidden="true" tabindex="-1"></a>dy <span class="op">=</span> <span class="fl">0.07</span></span>
<span id="cb19-79"><a href="#cb19-79" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-80"><a href="#cb19-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-81"><a href="#cb19-81" aria-hidden="true" tabindex="-1"></a>And finally I'll define some code for getting the raw data into slightly more manageable shape, and to calculate a counting rate over time from the timestamps of each count.</span>
<span id="cb19-82"><a href="#cb19-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-85"><a href="#cb19-85" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-86"><a href="#cb19-86" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Code for getting the raw data into slightly more manageable shape."</span></span>
<span id="cb19-87"><a href="#cb19-87" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> wrangle(data, week_map<span class="op">=</span>dst_start):</span>
<span id="cb19-88"><a href="#cb19-88" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> data.reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-89"><a href="#cb19-89" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"username"</span>] <span class="op">=</span> data[<span class="st">"username"</span>].<span class="bu">apply</span>(apply_alias)</span>
<span id="cb19-90"><a href="#cb19-90" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"timestamp"</span>] <span class="op">=</span> data[<span class="st">"timestamp"</span>] <span class="op">-</span> OFFSET</span>
<span id="cb19-91"><a href="#cb19-91" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"date"</span>] <span class="op">=</span> pd.to_datetime(data[<span class="st">"timestamp"</span>], unit<span class="op">=</span><span class="st">"s"</span>)</span>
<span id="cb19-92"><a href="#cb19-92" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">'time'</span>] <span class="op">=</span> (data[<span class="st">'timestamp'</span>]) <span class="op">%</span> units.DAY</span>
<span id="cb19-93"><a href="#cb19-93" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"week"</span>] <span class="op">=</span> (np.floor((data[<span class="st">"timestamp"</span>]</span>
<span id="cb19-94"><a href="#cb19-94" aria-hidden="true" tabindex="-1"></a>                              <span class="op">-</span> pd.to_datetime(data[<span class="st">"timestamp"</span>], unit<span class="op">=</span><span class="st">"s"</span>).dt.year.<span class="bu">map</span>(week_map))</span>
<span id="cb19-95"><a href="#cb19-95" aria-hidden="true" tabindex="-1"></a>                             <span class="op">/</span> WEEK)</span>
<span id="cb19-96"><a href="#cb19-96" aria-hidden="true" tabindex="-1"></a>                    .astype(<span class="bu">int</span>))</span>
<span id="cb19-97"><a href="#cb19-97" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"year"</span>] <span class="op">=</span> data[<span class="st">"date"</span>].dt.year</span>
<span id="cb19-98"><a href="#cb19-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data</span>
<span id="cb19-99"><a href="#cb19-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-100"><a href="#cb19-100" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_kdes(df):</span>
<span id="cb19-101"><a href="#cb19-101" aria-hidden="true" tabindex="-1"></a>    n_weeks <span class="op">=</span> <span class="bu">len</span>(df[<span class="st">"week"</span>].unique())</span>
<span id="cb19-102"><a href="#cb19-102" aria-hidden="true" tabindex="-1"></a>    kdes <span class="op">=</span> (df</span>
<span id="cb19-103"><a href="#cb19-103" aria-hidden="true" tabindex="-1"></a>            .groupby(<span class="st">"week"</span>)[<span class="st">"time"</span>]</span>
<span id="cb19-104"><a href="#cb19-104" aria-hidden="true" tabindex="-1"></a>            .<span class="bu">apply</span>(<span class="kw">lambda</span> x: pd.Series(analysis.fft_kde(</span>
<span id="cb19-105"><a href="#cb19-105" aria-hidden="true" tabindex="-1"></a>                x,</span>
<span id="cb19-106"><a href="#cb19-106" aria-hidden="true" tabindex="-1"></a>                nbins,</span>
<span id="cb19-107"><a href="#cb19-107" aria-hidden="true" tabindex="-1"></a>                kernel<span class="op">=</span><span class="st">"normal_distribution"</span>,</span>
<span id="cb19-108"><a href="#cb19-108" aria-hidden="true" tabindex="-1"></a>                sigma<span class="op">=</span><span class="fl">0.02</span>)[<span class="dv">1</span>] <span class="op">*</span> nbins))</span>
<span id="cb19-109"><a href="#cb19-109" aria-hidden="true" tabindex="-1"></a>            .reset_index()[[<span class="st">"week"</span>, <span class="st">"time"</span>]])</span>
<span id="cb19-110"><a href="#cb19-110" aria-hidden="true" tabindex="-1"></a>    kdes[<span class="st">"time_axis"</span>] <span class="op">=</span> np.hstack(n_weeks<span class="op">*</span>[time_axis])</span>
<span id="cb19-111"><a href="#cb19-111" aria-hidden="true" tabindex="-1"></a>    kdes.columns <span class="op">=</span> [<span class="st">"week"</span>, <span class="st">"rate"</span>, <span class="st">"time"</span>]</span>
<span id="cb19-112"><a href="#cb19-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> kdes</span>
<span id="cb19-113"><a href="#cb19-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-114"><a href="#cb19-114" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-115"><a href="#cb19-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-116"><a href="#cb19-116" aria-hidden="true" tabindex="-1"></a>With that out of the way, I'll select the weeks just before the start of DST and the weeks just after the end of DST for every year in r/counting's history. Then, I can plot the distribution of counts throughout the day for the week before and the week after the introduction of DST, and see how they differ:</span>
<span id="cb19-117"><a href="#cb19-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-120"><a href="#cb19-120" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-121"><a href="#cb19-121" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> query(x):</span>
<span id="cb19-122"><a href="#cb19-122" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="ss">f"select timestamp, username from comments where timestamp between "</span></span>
<span id="cb19-123"><a href="#cb19-123" aria-hidden="true" tabindex="-1"></a>            <span class="ss">f"</span><span class="sc">{</span>x <span class="op">+</span> OFFSET <span class="op">+</span> minval <span class="op">*</span> WEEK<span class="sc">}</span><span class="ss"> and </span><span class="sc">{</span>x <span class="op">+</span> OFFSET <span class="op">+</span> maxval <span class="op">*</span> WEEK<span class="sc">}</span><span class="ss"> "</span></span>
<span id="cb19-124"><a href="#cb19-124" aria-hidden="true" tabindex="-1"></a>            <span class="ss">f"order by timestamp"</span>)</span>
<span id="cb19-125"><a href="#cb19-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-126"><a href="#cb19-126" aria-hidden="true" tabindex="-1"></a>spring_all <span class="op">=</span> wrangle(pd.concat([pd.read_sql(query(x), db) <span class="cf">for</span> x <span class="kw">in</span> dst_start.values()]))</span>
<span id="cb19-127"><a href="#cb19-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-128"><a href="#cb19-128" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mask(df):</span>
<span id="cb19-129"><a href="#cb19-129" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ((df[<span class="st">"date"</span>].dt.weekday <span class="op">&lt;</span> <span class="dv">5</span>)</span>
<span id="cb19-130"><a href="#cb19-130" aria-hidden="true" tabindex="-1"></a>            <span class="op">&amp;</span> (<span class="op">-</span><span class="dv">2</span> <span class="op">&lt;=</span> df[<span class="st">"week"</span>])</span>
<span id="cb19-131"><a href="#cb19-131" aria-hidden="true" tabindex="-1"></a>            <span class="op">&amp;</span> (df[<span class="st">"week"</span>] <span class="op">&lt;</span> <span class="dv">2</span>))</span>
<span id="cb19-132"><a href="#cb19-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-133"><a href="#cb19-133" aria-hidden="true" tabindex="-1"></a>spring <span class="op">=</span> spring_all[mask(spring_all)].copy()</span>
<span id="cb19-134"><a href="#cb19-134" aria-hidden="true" tabindex="-1"></a>spring_kdes <span class="op">=</span> generate_kdes(spring)</span>
<span id="cb19-135"><a href="#cb19-135" aria-hidden="true" tabindex="-1"></a>week_map <span class="op">=</span> {<span class="op">-</span><span class="dv">2</span>: <span class="st">"Control without DST"</span>,</span>
<span id="cb19-136"><a href="#cb19-136" aria-hidden="true" tabindex="-1"></a>            <span class="op">-</span><span class="dv">1</span>: <span class="st">"Without DST"</span>,</span>
<span id="cb19-137"><a href="#cb19-137" aria-hidden="true" tabindex="-1"></a>            <span class="dv">0</span>: <span class="st">"With DST"</span>,</span>
<span id="cb19-138"><a href="#cb19-138" aria-hidden="true" tabindex="-1"></a>            <span class="dv">1</span>: <span class="st">"Control with DST"</span>}</span>
<span id="cb19-139"><a href="#cb19-139" aria-hidden="true" tabindex="-1"></a>spring_kdes[<span class="st">"week_name"</span>] <span class="op">=</span> spring_kdes[<span class="st">"week"</span>].<span class="bu">map</span>(week_map)</span>
<span id="cb19-140"><a href="#cb19-140" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> week <span class="kw">in</span> [<span class="st">"With DST"</span>, <span class="st">"Without DST"</span>]:</span>
<span id="cb19-141"><a href="#cb19-141" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> spring_kdes.query(<span class="st">"week_name == @week"</span>)</span>
<span id="cb19-142"><a href="#cb19-142" aria-hidden="true" tabindex="-1"></a>    plt.fill_between(df[<span class="st">"time"</span>], df[<span class="st">"rate"</span>], alpha<span class="op">=</span><span class="fl">0.8</span>, label<span class="op">=</span>week)</span>
<span id="cb19-143"><a href="#cb19-143" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.gca()</span>
<span id="cb19-144"><a href="#cb19-144" aria-hidden="true" tabindex="-1"></a>plots.make_time_axis(ax)</span>
<span id="cb19-145"><a href="#cb19-145" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Counting rate (arbitrary units)"</span>)</span>
<span id="cb19-146"><a href="#cb19-146" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Time of Day (UTC - 5)"</span>)</span>
<span id="cb19-147"><a href="#cb19-147" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb19-148"><a href="#cb19-148" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb19-149"><a href="#cb19-149" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-150"><a href="#cb19-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-151"><a href="#cb19-151" aria-hidden="true" tabindex="-1"></a>The shape of the two plots is similar, and it looks like the plot with DST is generally leading the one without, as would be expected if one was just a rigid shift of the other. But it's certainly not a perfect match, and it's hard to see from the curves just how much the DST curve is leading.</span>
<span id="cb19-152"><a href="#cb19-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-153"><a href="#cb19-153" aria-hidden="true" tabindex="-1"></a>I can try and see what the optimal shift of the DST curve would be to get it to match the curve without DST.</span>
<span id="cb19-154"><a href="#cb19-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-157"><a href="#cb19-157" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-158"><a href="#cb19-158" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_shifted_overlap(df, week1, week2):</span>
<span id="cb19-159"><a href="#cb19-159" aria-hidden="true" tabindex="-1"></a>    fixed <span class="op">=</span> df.loc[df[<span class="st">"week_name"</span>] <span class="op">==</span> week2, <span class="st">"rate"</span>].to_numpy()</span>
<span id="cb19-160"><a href="#cb19-160" aria-hidden="true" tabindex="-1"></a>    rotating <span class="op">=</span> df.loc[df[<span class="st">"week_name"</span>] <span class="op">==</span> week1, <span class="st">"rate"</span>].to_numpy()</span>
<span id="cb19-161"><a href="#cb19-161" aria-hidden="true" tabindex="-1"></a>    norm <span class="op">=</span> np.trapz(fixed <span class="op">*</span> rotating, x<span class="op">=</span>time_axis)</span>
<span id="cb19-162"><a href="#cb19-162" aria-hidden="true" tabindex="-1"></a>    shifts <span class="op">=</span> [np.trapz(fixed <span class="op">*</span> np.roll(rotating, i), x<span class="op">=</span>time_axis) <span class="op">/</span> norm <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(fixed))]</span>
<span id="cb19-163"><a href="#cb19-163" aria-hidden="true" tabindex="-1"></a>    optimal_shift <span class="op">=</span> (np.argmax(shifts) <span class="op">+</span> nbins <span class="op">/</span> <span class="dv">2</span>) <span class="op">%</span> nbins <span class="op">-</span> nbins<span class="op">/</span><span class="dv">2</span></span>
<span id="cb19-164"><a href="#cb19-164" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> shifts, optimal_shift</span>
<span id="cb19-165"><a href="#cb19-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-166"><a href="#cb19-166" aria-hidden="true" tabindex="-1"></a>shifts, optimal_shift <span class="op">=</span> calculate_shifted_overlap(spring_kdes, <span class="st">"With DST"</span>,<span class="st">"Without DST"</span>)</span>
<span id="cb19-167"><a href="#cb19-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-168"><a href="#cb19-168" aria-hidden="true" tabindex="-1"></a>plt.plot(shifts)</span>
<span id="cb19-169"><a href="#cb19-169" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>, <span class="bu">len</span>(shifts))</span>
<span id="cb19-170"><a href="#cb19-170" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.gca()</span>
<span id="cb19-171"><a href="#cb19-171" aria-hidden="true" tabindex="-1"></a>ticks, labels <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>[(x <span class="op">*</span> <span class="dv">120</span>, <span class="ss">f"</span><span class="sc">{</span>x<span class="sc">:02d}</span><span class="ss">:00"</span>) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">25</span>, <span class="dv">3</span>)])</span>
<span id="cb19-172"><a href="#cb19-172" aria-hidden="true" tabindex="-1"></a>ax.set_xticks(ticks)</span>
<span id="cb19-173"><a href="#cb19-173" aria-hidden="true" tabindex="-1"></a>ax.set_xticklabels(labels)</span>
<span id="cb19-174"><a href="#cb19-174" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The optimal shift is </span><span class="sc">{</span><span class="bu">int</span>(optimal_shift <span class="op">*</span> BIN_TO_MINUTE)<span class="sc">}</span><span class="ss"> minutes."</span>)</span>
<span id="cb19-175"><a href="#cb19-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-176"><a href="#cb19-176" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Shift (hours)"</span>)</span>
<span id="cb19-177"><a href="#cb19-177" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Similarity score"</span>)</span>
<span id="cb19-178"><a href="#cb19-178" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb19-179"><a href="#cb19-179" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-180"><a href="#cb19-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-181"><a href="#cb19-181" aria-hidden="true" tabindex="-1"></a>That's a bit less than one hour, but it's still suggestive. Apparently it *is* possoible to use the counting data to determine whether or not DST is currently active.</span>
<span id="cb19-182"><a href="#cb19-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-183"><a href="#cb19-183" aria-hidden="true" tabindex="-1"></a>So, case closed, right?</span>
<span id="cb19-184"><a href="#cb19-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-185"><a href="#cb19-185" aria-hidden="true" tabindex="-1"></a><span class="fu"># Validating the model</span></span>
<span id="cb19-186"><a href="#cb19-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-187"><a href="#cb19-187" aria-hidden="true" tabindex="-1"></a>Not so fast.</span>
<span id="cb19-188"><a href="#cb19-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-189"><a href="#cb19-189" aria-hidden="true" tabindex="-1"></a>It could be that there's a shift of one hour every week and DST has nothing to do with it! More seriously, there are other changes happening throughout the time period apart from DST; in the spring the days are getting longer, particularly the evenings, and maybe that's what's driving the change. And I haven't at all looked at what happens when the clocks go back.</span>
<span id="cb19-190"><a href="#cb19-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-191"><a href="#cb19-191" aria-hidden="true" tabindex="-1"></a><span class="fu">## Adding more weeks</span></span>
<span id="cb19-192"><a href="#cb19-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-193"><a href="#cb19-193" aria-hidden="true" tabindex="-1"></a>Let's start by looking at what happens before DST is active. For the preceding analysis to be valid, the distribution of counts throughout the day would need to be basically the same in the two weeks before the start of DST.</span>
<span id="cb19-194"><a href="#cb19-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-197"><a href="#cb19-197" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-198"><a href="#cb19-198" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> week <span class="kw">in</span> [<span class="st">"Without DST"</span>, <span class="st">"Control without DST"</span>]:</span>
<span id="cb19-199"><a href="#cb19-199" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> spring_kdes.query(<span class="st">"week_name == @week"</span>)</span>
<span id="cb19-200"><a href="#cb19-200" aria-hidden="true" tabindex="-1"></a>    plt.fill_between(df[<span class="st">"time"</span>], df[<span class="st">"rate"</span>], alpha<span class="op">=</span><span class="fl">0.8</span>, label<span class="op">=</span>week)</span>
<span id="cb19-201"><a href="#cb19-201" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.gca()</span>
<span id="cb19-202"><a href="#cb19-202" aria-hidden="true" tabindex="-1"></a>plots.make_time_axis(ax)</span>
<span id="cb19-203"><a href="#cb19-203" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Counting rate (arbitrary units)"</span>)</span>
<span id="cb19-204"><a href="#cb19-204" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Time of Day (UTC - 5)"</span>)</span>
<span id="cb19-205"><a href="#cb19-205" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb19-206"><a href="#cb19-206" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb19-207"><a href="#cb19-207" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-208"><a href="#cb19-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-209"><a href="#cb19-209" aria-hidden="true" tabindex="-1"></a>Hm. Those two curves might be slightly more aligned than the two with and without DST, but it's not super clear. I can check the optimal shift</span>
<span id="cb19-210"><a href="#cb19-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-213"><a href="#cb19-213" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-214"><a href="#cb19-214" aria-hidden="true" tabindex="-1"></a>_, optimal_shift <span class="op">=</span> calculate_shifted_overlap(spring_kdes, <span class="st">"Without DST"</span>, <span class="st">"Control without DST"</span>)</span>
<span id="cb19-215"><a href="#cb19-215" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The optimal shift is </span><span class="sc">{</span><span class="bu">int</span>(optimal_shift <span class="op">*</span> BIN_TO_MINUTE)<span class="sc">}</span><span class="ss"> minutes."</span>)</span>
<span id="cb19-216"><a href="#cb19-216" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-217"><a href="#cb19-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-218"><a href="#cb19-218" aria-hidden="true" tabindex="-1"></a>That's an even bigger shift than the one that happened when DST was introduced! I can plot the four curves for the two weeks before and after DST together and see if there's any obvious pattern.</span>
<span id="cb19-219"><a href="#cb19-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-222"><a href="#cb19-222" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-223"><a href="#cb19-223" aria-hidden="true" tabindex="-1"></a>spring_kdes[<span class="st">"shifted_rate"</span>] <span class="op">=</span> spring_kdes[<span class="st">"rate"</span>] <span class="op">+</span> (spring_kdes[<span class="st">"week"</span>] <span class="op">+</span> <span class="dv">2</span>) <span class="op">*</span> dy</span>
<span id="cb19-224"><a href="#cb19-224" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.lineplot(spring_kdes, x<span class="op">=</span><span class="st">"time"</span>, y<span class="op">=</span><span class="st">"shifted_rate"</span>, hue<span class="op">=</span><span class="st">"week_name"</span>)</span>
<span id="cb19-225"><a href="#cb19-225" aria-hidden="true" tabindex="-1"></a>ax.legend_.set_title(<span class="st">"Week"</span>)</span>
<span id="cb19-226"><a href="#cb19-226" aria-hidden="true" tabindex="-1"></a>plots.make_time_axis(ax)</span>
<span id="cb19-227"><a href="#cb19-227" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">"upper center"</span>, ncol<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb19-228"><a href="#cb19-228" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Counting rate (arbitrary units)"</span>)</span>
<span id="cb19-229"><a href="#cb19-229" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Time of Day (UTC - 5)"</span>)</span>
<span id="cb19-230"><a href="#cb19-230" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="dv">0</span>, <span class="fl">0.34</span>)</span>
<span id="cb19-231"><a href="#cb19-231" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb19-232"><a href="#cb19-232" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-233"><a href="#cb19-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-234"><a href="#cb19-234" aria-hidden="true" tabindex="-1"></a>If you didn't have the legend, would you be able to tell which two of these curves were with DST and which were without? It seems that the variation from week to week is so big that any DST signal that might be present in the data is just swamped by all the noise.</span>
<span id="cb19-235"><a href="#cb19-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-236"><a href="#cb19-236" aria-hidden="true" tabindex="-1"></a><span class="fu">## Including the end of DST</span></span>
<span id="cb19-237"><a href="#cb19-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-238"><a href="#cb19-238" aria-hidden="true" tabindex="-1"></a>I can try and see if including the data for the end of DST makes any difference</span>
<span id="cb19-239"><a href="#cb19-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-242"><a href="#cb19-242" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-243"><a href="#cb19-243" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-autumn-kdes</span></span>
<span id="cb19-244"><a href="#cb19-244" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: The aggregated activity on r/counting in the two weeks on either side of the start/end of DST.</span></span>
<span id="cb19-245"><a href="#cb19-245" aria-hidden="true" tabindex="-1"></a>autumn_all <span class="op">=</span> wrangle(pd.concat([pd.read_sql(query(x), db) <span class="cf">for</span> x <span class="kw">in</span> dst_end.values()]), dst_end)</span>
<span id="cb19-246"><a href="#cb19-246" aria-hidden="true" tabindex="-1"></a>autumn <span class="op">=</span> autumn_all[mask(autumn_all)].copy()</span>
<span id="cb19-247"><a href="#cb19-247" aria-hidden="true" tabindex="-1"></a>autumn[<span class="st">"week"</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span> <span class="op">-</span> autumn_all[<span class="st">"week"</span>]</span>
<span id="cb19-248"><a href="#cb19-248" aria-hidden="true" tabindex="-1"></a>kdes <span class="op">=</span> generate_kdes(pd.concat([spring, autumn]))</span>
<span id="cb19-249"><a href="#cb19-249" aria-hidden="true" tabindex="-1"></a>kdes[<span class="st">"week_name"</span>] <span class="op">=</span> kdes[<span class="st">"week"</span>].<span class="bu">map</span>(week_map)</span>
<span id="cb19-250"><a href="#cb19-250" aria-hidden="true" tabindex="-1"></a>kdes[<span class="st">"shifted_rate"</span>] <span class="op">=</span> kdes[<span class="st">"rate"</span>] <span class="op">+</span> (kdes[<span class="st">"week"</span>] <span class="op">+</span> <span class="dv">2</span>) <span class="op">*</span> dy</span>
<span id="cb19-251"><a href="#cb19-251" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.lineplot(kdes, x<span class="op">=</span><span class="st">"time"</span>, y<span class="op">=</span><span class="st">"shifted_rate"</span>, hue<span class="op">=</span><span class="st">"week_name"</span>)</span>
<span id="cb19-252"><a href="#cb19-252" aria-hidden="true" tabindex="-1"></a>ax.legend_.set_title(<span class="st">"Week"</span>)</span>
<span id="cb19-253"><a href="#cb19-253" aria-hidden="true" tabindex="-1"></a>plots.make_time_axis(ax)</span>
<span id="cb19-254"><a href="#cb19-254" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">"upper center"</span>, ncol<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb19-255"><a href="#cb19-255" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Counting rate (arbitrary units)"</span>)</span>
<span id="cb19-256"><a href="#cb19-256" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Time of Day (UTC - 5)"</span>)</span>
<span id="cb19-257"><a href="#cb19-257" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="dv">0</span>, <span class="fl">0.34</span>)</span>
<span id="cb19-258"><a href="#cb19-258" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb19-259"><a href="#cb19-259" aria-hidden="true" tabindex="-1"></a>_, optimal_shift <span class="op">=</span> calculate_shifted_overlap(kdes, <span class="st">"With DST"</span>, <span class="st">"Without DST"</span>)</span>
<span id="cb19-260"><a href="#cb19-260" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The optimal shift is </span><span class="sc">{</span><span class="bu">int</span>(optimal_shift <span class="op">*</span> BIN_TO_MINUTE)<span class="sc">}</span><span class="ss"> minutes."</span>)</span>
<span id="cb19-261"><a href="#cb19-261" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb19-262"><a href="#cb19-262" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-263"><a href="#cb19-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-264"><a href="#cb19-264" aria-hidden="true" tabindex="-1"></a>As before – would you be able to tell which of these graphs were with DST and which were without if you didn't have the legend?</span>
<span id="cb19-265"><a href="#cb19-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-266"><a href="#cb19-266" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summing up</span></span>
<span id="cb19-267"><a href="#cb19-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-268"><a href="#cb19-268" aria-hidden="true" tabindex="-1"></a>The validation of the model has revealed that the activity on r/counting varies enough on a week to week basis that my initial assumptions are incorrect, and I can't just treat the activity as a constant background with a DST signal on top. If I want to see the effect of DST, I'm going to have to come up with something more clever.</span>
<span id="cb19-269"><a href="#cb19-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-270"><a href="#cb19-270" aria-hidden="true" tabindex="-1"></a><span class="fu"># More Advanced Models</span></span>
<span id="cb19-271"><a href="#cb19-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-272"><a href="#cb19-272" aria-hidden="true" tabindex="-1"></a><span class="fu">## Disaggregating the years</span></span>
<span id="cb19-273"><a href="#cb19-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-274"><a href="#cb19-274" aria-hidden="true" tabindex="-1"></a>What I did in the previous section was to aggregate the activity on r/counting across all the years it's been active. After that, I honed in on specific weeks near the time of year when the clocks change, and asked if there was a rigid shift in the data.</span>
<span id="cb19-275"><a href="#cb19-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-276"><a href="#cb19-276" aria-hidden="true" tabindex="-1"></a>This analysis revealed that the activity on r/counting isn't stable over time. Maybe I'm losing information by aggregating all the years, and the signal would be clearer if I looked at each year separately.</span>
<span id="cb19-277"><a href="#cb19-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-278"><a href="#cb19-278" aria-hidden="true" tabindex="-1"></a>Before I can make these comparisons I'm going to need a way of boiling down the information. @fig-autumn-kdes and friends in the previous section showed that spotting the shift by eye is very difficult, and if the plot is further split into a new line for each year, it's going to become completely unreadable.</span>
<span id="cb19-279"><a href="#cb19-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-280"><a href="#cb19-280" aria-hidden="true" tabindex="-1"></a>What I need is a way of compressing each (week, year) pair to a single point, so that the plots are still legible even after disaggregating the years.</span>
<span id="cb19-281"><a href="#cb19-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-282"><a href="#cb19-282" aria-hidden="true" tabindex="-1"></a>I can use the fac t that the DST offset is exactly one hour to accomplish just this: For each week, I can calculate how much the distribution resembles that of the week before, and I can also calculate how much the distribution resembles the 1 hour *shifted* distribution from the week before.</span>
<span id="cb19-283"><a href="#cb19-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-284"><a href="#cb19-284" aria-hidden="true" tabindex="-1"></a>For most of the year, it should be the case that the unshifted distribution is more similar then the shifted distribution. But, for the week where the clocks change, the shifted distribution should be more similar. So, I can calculate the similarity of the lagged and shifted distribution, and subtract the similarity of just the lagged distribution, and I have a DST fingerprint. For most weeks, it should give a negative value, but for the week where the clocks change it should give a positive value.</span>
<span id="cb19-285"><a href="#cb19-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-286"><a href="#cb19-286" aria-hidden="true" tabindex="-1"></a>Let's see how it goes!</span>
<span id="cb19-287"><a href="#cb19-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-290"><a href="#cb19-290" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-291"><a href="#cb19-291" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dst_fingerprint(df, period<span class="op">=</span><span class="st">"spring"</span>):</span>
<span id="cb19-292"><a href="#cb19-292" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate the dst fingerprint for a single year"""</span></span>
<span id="cb19-293"><a href="#cb19-293" aria-hidden="true" tabindex="-1"></a>    transitions <span class="op">=</span> dst_start <span class="cf">if</span> period <span class="op">==</span> <span class="st">"spring"</span> <span class="cf">else</span> dst_end</span>
<span id="cb19-294"><a href="#cb19-294" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> df.resample(<span class="st">"300s"</span>, on<span class="op">=</span><span class="st">"date"</span>).size()</span>
<span id="cb19-295"><a href="#cb19-295" aria-hidden="true" tabindex="-1"></a>    rates <span class="op">=</span> x.div(x.groupby(pd.Grouper(freq<span class="op">=</span><span class="st">"1d"</span>)).transform(<span class="st">"sum"</span>)).to_frame(name<span class="op">=</span><span class="st">"rate"</span>)</span>
<span id="cb19-296"><a href="#cb19-296" aria-hidden="true" tabindex="-1"></a>    rates.index <span class="op">=</span> rates.index <span class="op">-</span> pd.to_datetime(rates.index.year.<span class="bu">map</span>(transitions), unit<span class="op">=</span><span class="st">"s"</span>)</span>
<span id="cb19-297"><a href="#cb19-297" aria-hidden="true" tabindex="-1"></a>    shifted <span class="op">=</span> rates.shift(freq<span class="op">=</span><span class="st">"7d"</span>)</span>
<span id="cb19-298"><a href="#cb19-298" aria-hidden="true" tabindex="-1"></a>    shift <span class="op">=</span> <span class="st">"-1h"</span> <span class="cf">if</span> period <span class="op">==</span> <span class="st">"spring"</span> <span class="cf">else</span> <span class="st">"1h"</span></span>
<span id="cb19-299"><a href="#cb19-299" aria-hidden="true" tabindex="-1"></a>    dst_shifted <span class="op">=</span> shifted.shift(freq<span class="op">=</span>shift)</span>
<span id="cb19-300"><a href="#cb19-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-301"><a href="#cb19-301" aria-hidden="true" tabindex="-1"></a>    dfs <span class="op">=</span> []</span>
<span id="cb19-302"><a href="#cb19-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-303"><a href="#cb19-303" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> df <span class="kw">in</span> [shifted, dst_shifted]:</span>
<span id="cb19-304"><a href="#cb19-304" aria-hidden="true" tabindex="-1"></a>        background <span class="op">=</span> pd.Series((maxval <span class="op">-</span> minval) <span class="op">*</span> [np.nan], <span class="bu">range</span>(minval, maxval), name<span class="op">=</span><span class="st">"delta"</span>)</span>
<span id="cb19-305"><a href="#cb19-305" aria-hidden="true" tabindex="-1"></a>        background.index.name <span class="op">=</span> <span class="st">"date"</span></span>
<span id="cb19-306"><a href="#cb19-306" aria-hidden="true" tabindex="-1"></a>        f1 <span class="op">=</span> pd.merge(rates, df, left_index<span class="op">=</span><span class="va">True</span>, right_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-307"><a href="#cb19-307" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(f1) <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb19-308"><a href="#cb19-308" aria-hidden="true" tabindex="-1"></a>            f1[<span class="st">"delta"</span>] <span class="op">=</span> (f1[<span class="st">"rate_x"</span>] <span class="op">-</span> f1[<span class="st">"rate_y"</span>]) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb19-309"><a href="#cb19-309" aria-hidden="true" tabindex="-1"></a>            series <span class="op">=</span> f1.groupby(f1.index.days <span class="op">//</span> <span class="dv">7</span>)[<span class="st">"delta"</span>].<span class="bu">sum</span>()</span>
<span id="cb19-310"><a href="#cb19-310" aria-hidden="true" tabindex="-1"></a>            background.loc[series.index] <span class="op">=</span> series</span>
<span id="cb19-311"><a href="#cb19-311" aria-hidden="true" tabindex="-1"></a>        dfs.append(background)</span>
<span id="cb19-312"><a href="#cb19-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-313"><a href="#cb19-313" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dfs[<span class="dv">1</span>] <span class="op">-</span> dfs[<span class="dv">0</span>]</span>
<span id="cb19-314"><a href="#cb19-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-315"><a href="#cb19-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-316"><a href="#cb19-316" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multiple_dst_fingerprints(df, period<span class="op">=</span><span class="st">"spring"</span>):</span>
<span id="cb19-317"><a href="#cb19-317" aria-hidden="true" tabindex="-1"></a>    groups <span class="op">=</span> df.groupby(<span class="st">"year"</span>).<span class="bu">apply</span>(dst_fingerprint, period<span class="op">=</span>period)</span>
<span id="cb19-318"><a href="#cb19-318" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> groups.reset_index().melt(id_vars<span class="op">=</span><span class="st">"year"</span>)</span>
<span id="cb19-319"><a href="#cb19-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-320"><a href="#cb19-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-321"><a href="#cb19-321" aria-hidden="true" tabindex="-1"></a>week_norm <span class="op">=</span> spring_all.groupby([<span class="st">"year"</span>, <span class="st">"username"</span>]).size() <span class="op">/</span> spring_all.groupby(<span class="st">"year"</span>).size()</span>
<span id="cb19-322"><a href="#cb19-322" aria-hidden="true" tabindex="-1"></a>year_norm <span class="op">=</span> spring_all.groupby(<span class="st">"year"</span>).size() <span class="op">/</span> <span class="bu">len</span>(spring_all)</span>
<span id="cb19-323"><a href="#cb19-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-324"><a href="#cb19-324" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> multiple_dst_fingerprints(spring_all)</span>
<span id="cb19-325"><a href="#cb19-325" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(df, x<span class="op">=</span><span class="st">"date"</span>, y<span class="op">=</span><span class="st">"value"</span>, hue<span class="op">=</span><span class="st">"year"</span>, palette<span class="op">=</span><span class="st">"plasma"</span>)</span>
<span id="cb19-326"><a href="#cb19-326" aria-hidden="true" tabindex="-1"></a>sns.lineplot(</span>
<span id="cb19-327"><a href="#cb19-327" aria-hidden="true" tabindex="-1"></a>    df.dropna().set_index([<span class="st">"year"</span>, <span class="st">"date"</span>])[<span class="st">"value"</span>].mul(year_norm).groupby(level<span class="op">=</span><span class="dv">1</span>).<span class="bu">sum</span>(),</span>
<span id="cb19-328"><a href="#cb19-328" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"0.4"</span>,</span>
<span id="cb19-329"><a href="#cb19-329" aria-hidden="true" tabindex="-1"></a>    legend<span class="op">=</span><span class="va">False</span></span>
<span id="cb19-330"><a href="#cb19-330" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-331"><a href="#cb19-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-332"><a href="#cb19-332" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"0.5"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb19-333"><a href="#cb19-333" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Weeks after start of DST"</span>)</span>
<span id="cb19-334"><a href="#cb19-334" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"DST fingerprint"</span>)</span>
<span id="cb19-335"><a href="#cb19-335" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb19-336"><a href="#cb19-336" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-337"><a href="#cb19-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-338"><a href="#cb19-338" aria-hidden="true" tabindex="-1"></a>Hm. This isn't very promising. The DST signal should show up in this plot in the fact that the points at 0 should lie significantly higher than all the others. That's not the case at all.</span>
<span id="cb19-339"><a href="#cb19-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-340"><a href="#cb19-340" aria-hidden="true" tabindex="-1"></a>I can do the same thing for when DST ends, just for good measure, to see if the signal shows up there:</span>
<span id="cb19-341"><a href="#cb19-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-344"><a href="#cb19-344" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-345"><a href="#cb19-345" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> multiple_dst_fingerprints(autumn_all, <span class="st">"autumn"</span>)</span>
<span id="cb19-346"><a href="#cb19-346" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(df, x<span class="op">=</span><span class="st">"date"</span>, y<span class="op">=</span><span class="st">"value"</span>, hue<span class="op">=</span><span class="st">"year"</span>, palette<span class="op">=</span><span class="st">"plasma"</span>)</span>
<span id="cb19-347"><a href="#cb19-347" aria-hidden="true" tabindex="-1"></a>sns.lineplot(</span>
<span id="cb19-348"><a href="#cb19-348" aria-hidden="true" tabindex="-1"></a>    df.dropna().set_index([<span class="st">"year"</span>, <span class="st">"date"</span>])[<span class="st">"value"</span>].mul(year_norm).groupby(level<span class="op">=</span><span class="dv">1</span>).<span class="bu">sum</span>(),</span>
<span id="cb19-349"><a href="#cb19-349" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"0.4"</span>,</span>
<span id="cb19-350"><a href="#cb19-350" aria-hidden="true" tabindex="-1"></a>    legend<span class="op">=</span><span class="va">False</span></span>
<span id="cb19-351"><a href="#cb19-351" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-352"><a href="#cb19-352" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"0.5"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb19-353"><a href="#cb19-353" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Weeks after end of DST"</span>)</span>
<span id="cb19-354"><a href="#cb19-354" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"DST fingerprint"</span>)</span>
<span id="cb19-355"><a href="#cb19-355" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb19-356"><a href="#cb19-356" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-357"><a href="#cb19-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-358"><a href="#cb19-358" aria-hidden="true" tabindex="-1"></a>Unfortunately, that didn't seem to show the signal either. Before giving up completely and abandoning this as a fool's errand, there's one or two more things I can try.</span>
<span id="cb19-359"><a href="#cb19-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-360"><a href="#cb19-360" aria-hidden="true" tabindex="-1"></a><span class="fu">## Disaggregating the different counters</span></span>
<span id="cb19-361"><a href="#cb19-361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-362"><a href="#cb19-362" aria-hidden="true" tabindex="-1"></a>Regulars of r/counting will know that it's not the same people who count every week. If proof of this is needed, you can take a look at the top weekly counters list and see that it really isn't just a repeat from week to week. Perhaps this is one cause of the lack of pattern in the counting times. It's certainly possible to imagine a world where counters are perfectly regular, but the different schedules of different counters coupled with their different activity from week to week adds up to a huge mess.</span>
<span id="cb19-363"><a href="#cb19-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-364"><a href="#cb19-364" aria-hidden="true" tabindex="-1"></a>So I can keep going with the disaggregation, and see if I get a clearer signal when we compare the activity of individual counters from week to week.</span>
<span id="cb19-365"><a href="#cb19-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-368"><a href="#cb19-368" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-369"><a href="#cb19-369" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> username_fingerprint(df, period<span class="op">=</span><span class="st">"spring"</span>):</span>
<span id="cb19-370"><a href="#cb19-370" aria-hidden="true" tabindex="-1"></a>    fingerprint <span class="op">=</span> (df.groupby([<span class="st">"year"</span>, <span class="st">"username"</span>])</span>
<span id="cb19-371"><a href="#cb19-371" aria-hidden="true" tabindex="-1"></a>                   .<span class="bu">apply</span>(dst_fingerprint, period<span class="op">=</span>period)</span>
<span id="cb19-372"><a href="#cb19-372" aria-hidden="true" tabindex="-1"></a>                   .reset_index()</span>
<span id="cb19-373"><a href="#cb19-373" aria-hidden="true" tabindex="-1"></a>                   .melt(id_vars<span class="op">=</span>[<span class="st">"year"</span>, <span class="st">"username"</span>], var_name<span class="op">=</span><span class="st">"week"</span>)</span>
<span id="cb19-374"><a href="#cb19-374" aria-hidden="true" tabindex="-1"></a>                   .set_index([<span class="st">"year"</span>, <span class="st">"username"</span>, <span class="st">"week"</span>])[<span class="st">"value"</span>])</span>
<span id="cb19-375"><a href="#cb19-375" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fingerprint</span>
<span id="cb19-376"><a href="#cb19-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-377"><a href="#cb19-377" aria-hidden="true" tabindex="-1"></a>fingerprints <span class="op">=</span> username_fingerprint(spring_all)</span>
<span id="cb19-378"><a href="#cb19-378" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> (</span>
<span id="cb19-379"><a href="#cb19-379" aria-hidden="true" tabindex="-1"></a>    fingerprints.dropna()</span>
<span id="cb19-380"><a href="#cb19-380" aria-hidden="true" tabindex="-1"></a>    .mul(week_norm)</span>
<span id="cb19-381"><a href="#cb19-381" aria-hidden="true" tabindex="-1"></a>    .groupby(level<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">2</span>])</span>
<span id="cb19-382"><a href="#cb19-382" aria-hidden="true" tabindex="-1"></a>    .<span class="bu">sum</span>()</span>
<span id="cb19-383"><a href="#cb19-383" aria-hidden="true" tabindex="-1"></a>    .reset_index(name<span class="op">=</span><span class="st">"fingerprint"</span>)</span>
<span id="cb19-384"><a href="#cb19-384" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-385"><a href="#cb19-385" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(df, x<span class="op">=</span><span class="st">"week"</span>, y<span class="op">=</span><span class="st">"fingerprint"</span>, hue<span class="op">=</span><span class="st">"year"</span>, palette<span class="op">=</span><span class="st">"plasma"</span>)</span>
<span id="cb19-386"><a href="#cb19-386" aria-hidden="true" tabindex="-1"></a>sns.lineplot(</span>
<span id="cb19-387"><a href="#cb19-387" aria-hidden="true" tabindex="-1"></a>    df.set_index([<span class="st">"year"</span>, <span class="st">"week"</span>])[<span class="st">"fingerprint"</span>].mul(year_norm).groupby(level<span class="op">=</span><span class="dv">1</span>).<span class="bu">sum</span>(),</span>
<span id="cb19-388"><a href="#cb19-388" aria-hidden="true" tabindex="-1"></a>    ax<span class="op">=</span>ax,</span>
<span id="cb19-389"><a href="#cb19-389" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"0.4"</span>,</span>
<span id="cb19-390"><a href="#cb19-390" aria-hidden="true" tabindex="-1"></a>    legend<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb19-391"><a href="#cb19-391" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-392"><a href="#cb19-392" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"0.5"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb19-393"><a href="#cb19-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-394"><a href="#cb19-394" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Weeks after start of DST"</span>)</span>
<span id="cb19-395"><a href="#cb19-395" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"DST fingerprint"</span>)</span>
<span id="cb19-396"><a href="#cb19-396" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb19-397"><a href="#cb19-397" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-398"><a href="#cb19-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-399"><a href="#cb19-399" aria-hidden="true" tabindex="-1"></a>Looking at this graph almost makes me think I have a sign error in the way I've defined the DST fingerprint. I've double checked, and I don't think it's the case, but this certainly isn't the peak at 0 I was hoping to see.</span>
<span id="cb19-400"><a href="#cb19-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-401"><a href="#cb19-401" aria-hidden="true" tabindex="-1"></a><span class="fu">## Looking only at the most regular counters</span></span>
<span id="cb19-402"><a href="#cb19-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-403"><a href="#cb19-403" aria-hidden="true" tabindex="-1"></a>None of what I've tried so far has seemed to work. There's one last thing I can try: I can find out which counters were most regular in the period leading up to the start of DST each year, and only include them in the calculations</span>
<span id="cb19-404"><a href="#cb19-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-405"><a href="#cb19-405" aria-hidden="true" tabindex="-1"></a>To do that I'll need to slightly rework the code from <span class="co">[</span><span class="ot">*Section 1*</span><span class="co">]</span>{.spurious-link target="A first model"} for calculating the overlap between two different counting distributions. This will let me calculate the overlap for every counter for every year in the weeks around the onset of DST.</span>
<span id="cb19-406"><a href="#cb19-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-407"><a href="#cb19-407" aria-hidden="true" tabindex="-1"></a>Then it's just a bit of fidding with indices to find the 5 most regular counters two weeks before the start of DST for every year.</span>
<span id="cb19-408"><a href="#cb19-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-411"><a href="#cb19-411" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-412"><a href="#cb19-412" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> similarity_score(df):</span>
<span id="cb19-413"><a href="#cb19-413" aria-hidden="true" tabindex="-1"></a>    kdes <span class="op">=</span> generate_kdes(df)</span>
<span id="cb19-414"><a href="#cb19-414" aria-hidden="true" tabindex="-1"></a>    groups <span class="op">=</span> kdes.groupby(<span class="st">"week"</span>)[<span class="st">"rate"</span>]</span>
<span id="cb19-415"><a href="#cb19-415" aria-hidden="true" tabindex="-1"></a>    norm <span class="op">=</span> groups.transform(np.linalg.norm)</span>
<span id="cb19-416"><a href="#cb19-416" aria-hidden="true" tabindex="-1"></a>    kdes[<span class="st">"rate"</span>] <span class="op">/=</span> norm</span>
<span id="cb19-417"><a href="#cb19-417" aria-hidden="true" tabindex="-1"></a>    overlaps <span class="op">=</span> (</span>
<span id="cb19-418"><a href="#cb19-418" aria-hidden="true" tabindex="-1"></a>        (kdes.set_index([<span class="st">"week"</span>, <span class="st">"time"</span>]).groupby(<span class="st">"time"</span>)[<span class="st">"rate"</span>].diff() <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb19-419"><a href="#cb19-419" aria-hidden="true" tabindex="-1"></a>        .groupby(level<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb19-420"><a href="#cb19-420" aria-hidden="true" tabindex="-1"></a>        .<span class="bu">sum</span>()</span>
<span id="cb19-421"><a href="#cb19-421" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb19-422"><a href="#cb19-422" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">-</span> overlaps <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb19-423"><a href="#cb19-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-424"><a href="#cb19-424" aria-hidden="true" tabindex="-1"></a>scores <span class="op">=</span> spring_all.groupby([<span class="st">"year"</span>, <span class="st">"username"</span>]).<span class="bu">apply</span>(similarity_score)</span>
<span id="cb19-425"><a href="#cb19-425" aria-hidden="true" tabindex="-1"></a>scores <span class="op">=</span> scores[scores <span class="op">!=</span> <span class="dv">1</span>]</span>
<span id="cb19-426"><a href="#cb19-426" aria-hidden="true" tabindex="-1"></a>counters <span class="op">=</span> (</span>
<span id="cb19-427"><a href="#cb19-427" aria-hidden="true" tabindex="-1"></a>    scores</span>
<span id="cb19-428"><a href="#cb19-428" aria-hidden="true" tabindex="-1"></a>    .reset_index()</span>
<span id="cb19-429"><a href="#cb19-429" aria-hidden="true" tabindex="-1"></a>    .query(<span class="st">"week== -2"</span>)</span>
<span id="cb19-430"><a href="#cb19-430" aria-hidden="true" tabindex="-1"></a>    .sort_values([<span class="st">"year"</span>, <span class="st">"rate"</span>], ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb19-431"><a href="#cb19-431" aria-hidden="true" tabindex="-1"></a>    .groupby(<span class="st">"year"</span>)</span>
<span id="cb19-432"><a href="#cb19-432" aria-hidden="true" tabindex="-1"></a>    .head(<span class="dv">5</span>)</span>
<span id="cb19-433"><a href="#cb19-433" aria-hidden="true" tabindex="-1"></a>    .set_index([<span class="st">"year"</span>, <span class="st">"username"</span>])</span>
<span id="cb19-434"><a href="#cb19-434" aria-hidden="true" tabindex="-1"></a>    .index</span>
<span id="cb19-435"><a href="#cb19-435" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-436"><a href="#cb19-436" aria-hidden="true" tabindex="-1"></a>subset <span class="op">=</span> spring_all.set_index([<span class="st">"year"</span>, <span class="st">"username"</span>]).loc[counters]</span>
<span id="cb19-437"><a href="#cb19-437" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-438"><a href="#cb19-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-439"><a href="#cb19-439" aria-hidden="true" tabindex="-1"></a>With that out of the way, I can plot the average similarity score for each year and week</span>
<span id="cb19-440"><a href="#cb19-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-443"><a href="#cb19-443" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-444"><a href="#cb19-444" aria-hidden="true" tabindex="-1"></a>week_norm <span class="op">=</span> subset.groupby([<span class="st">"year"</span>, <span class="st">"username"</span>]).size() <span class="op">/</span> subset.groupby(<span class="st">"year"</span>).size()</span>
<span id="cb19-445"><a href="#cb19-445" aria-hidden="true" tabindex="-1"></a>year_norm <span class="op">=</span> subset.groupby(<span class="st">"year"</span>).size() <span class="op">/</span> <span class="bu">len</span>(subset)</span>
<span id="cb19-446"><a href="#cb19-446" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-447"><a href="#cb19-447" aria-hidden="true" tabindex="-1"></a>similarity <span class="op">=</span> (</span>
<span id="cb19-448"><a href="#cb19-448" aria-hidden="true" tabindex="-1"></a>    scores.reset_index(level<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb19-449"><a href="#cb19-449" aria-hidden="true" tabindex="-1"></a>    .loc[counters]</span>
<span id="cb19-450"><a href="#cb19-450" aria-hidden="true" tabindex="-1"></a>    .set_index(<span class="st">"week"</span>, append<span class="op">=</span><span class="va">True</span>)[<span class="st">"rate"</span>]</span>
<span id="cb19-451"><a href="#cb19-451" aria-hidden="true" tabindex="-1"></a>    .mul(week_norm)</span>
<span id="cb19-452"><a href="#cb19-452" aria-hidden="true" tabindex="-1"></a>    .groupby(level<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">2</span>])</span>
<span id="cb19-453"><a href="#cb19-453" aria-hidden="true" tabindex="-1"></a>    .<span class="bu">sum</span>()</span>
<span id="cb19-454"><a href="#cb19-454" aria-hidden="true" tabindex="-1"></a>    .reset_index(name<span class="op">=</span><span class="st">"similarity"</span>)</span>
<span id="cb19-455"><a href="#cb19-455" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-456"><a href="#cb19-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-457"><a href="#cb19-457" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.scatterplot(similarity, x<span class="op">=</span><span class="st">"week"</span>, y<span class="op">=</span><span class="st">"similarity"</span>, hue<span class="op">=</span><span class="st">"year"</span>, palette<span class="op">=</span><span class="st">"plasma"</span>)</span>
<span id="cb19-458"><a href="#cb19-458" aria-hidden="true" tabindex="-1"></a>sns.lineplot(</span>
<span id="cb19-459"><a href="#cb19-459" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb19-460"><a href="#cb19-460" aria-hidden="true" tabindex="-1"></a>        similarity.set_index([<span class="st">"year"</span>, <span class="st">"week"</span>])[<span class="st">"similarity"</span>]</span>
<span id="cb19-461"><a href="#cb19-461" aria-hidden="true" tabindex="-1"></a>        .mul(year_norm)</span>
<span id="cb19-462"><a href="#cb19-462" aria-hidden="true" tabindex="-1"></a>        .groupby(<span class="st">"week"</span>)</span>
<span id="cb19-463"><a href="#cb19-463" aria-hidden="true" tabindex="-1"></a>        .<span class="bu">sum</span>()</span>
<span id="cb19-464"><a href="#cb19-464" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb19-465"><a href="#cb19-465" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"0.4"</span>,</span>
<span id="cb19-466"><a href="#cb19-466" aria-hidden="true" tabindex="-1"></a>    ax<span class="op">=</span>ax,</span>
<span id="cb19-467"><a href="#cb19-467" aria-hidden="true" tabindex="-1"></a>    legend<span class="op">=</span><span class="va">False</span></span>
<span id="cb19-468"><a href="#cb19-468" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-469"><a href="#cb19-469" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Weeks after start of DST"</span>)</span>
<span id="cb19-470"><a href="#cb19-470" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Week consistency score"</span>)</span>
<span id="cb19-471"><a href="#cb19-471" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb19-472"><a href="#cb19-472" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-473"><a href="#cb19-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-474"><a href="#cb19-474" aria-hidden="true" tabindex="-1"></a>I've decided to work with the consistency score rather than the DST fingerprint<span class="ot">[^3]</span>, because I wanted to highlight the effect of the selection I've made. You can see on the graph that the score two weeks before the start of DST is signficantly higher than all the other weeks, and in particular the least consistent year for week -2 is much more consistent tht the least consistent year for all the other weeks.</span>
<span id="cb19-475"><a href="#cb19-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-476"><a href="#cb19-476" aria-hidden="true" tabindex="-1"></a>This apparent result is just an artefact of the way I've selected the data: I've limited my search to people who were very consistent two weeks before the onset of DST, so it's no surprise that the consistency is high here. The fact that the consistency is lower in the following weeks is due to a regression towards the mean.</span>
<span id="cb19-477"><a href="#cb19-477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-478"><a href="#cb19-478" aria-hidden="true" tabindex="-1"></a>That statistical artefact aside, it doesn't seem that this analysis has brought me any closer to finding a clear sign of DST in the counting data. With the consistency score, the sign of DST is a dip at 0, so the fact that the least consistent week is the week DST starts is suggestive. But it's not what I'd call proof.</span>
<span id="cb19-479"><a href="#cb19-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-480"><a href="#cb19-480" aria-hidden="true" tabindex="-1"></a><span class="fu"># Conclusion</span></span>
<span id="cb19-481"><a href="#cb19-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-482"><a href="#cb19-482" aria-hidden="true" tabindex="-1"></a>If you want to find out whether or not the US currently has DST, then looking at the comments on r/counting is not a viable method for doing so. I would suggest just googling it instead.</span>
<span id="cb19-483"><a href="#cb19-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-484"><a href="#cb19-484" aria-hidden="true" tabindex="-1"></a>This post ended up being much longer than expected (and a fair bit longer than the reddit comment that it's based on), mainly because I've had to change the conclusion along the way.</span>
<span id="cb19-485"><a href="#cb19-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-486"><a href="#cb19-486" aria-hidden="true" tabindex="-1"></a>In the original, and in my first draft, I wasn't as thorough with my robustness analysis as I've been here. That meant that I was more convinced by the hints of a DST signal in the data, and the conclusion reflected that. Unfortunately, this post has demonstrated that it just isn't there. On the positive side, the post has also demonstrated the value of checking assumptions, validating any model that you might come up with, and generally having a healthy dose of skepticism towards any new discoveries – especially your own.</span>
<span id="cb19-487"><a href="#cb19-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-488"><a href="#cb19-488" aria-hidden="true" tabindex="-1"></a>And that's perhaps as good a place as any to end.</span>
<span id="cb19-489"><a href="#cb19-489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-490"><a href="#cb19-490" aria-hidden="true" tabindex="-1"></a>Until next time!</span>
<span id="cb19-491"><a href="#cb19-491" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-492"><a href="#cb19-492" aria-hidden="true" tabindex="-1"></a><span class="ot">[^1]: </span>Apart from Hawaii and Arizona, which are weird</span>
<span id="cb19-493"><a href="#cb19-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-494"><a href="#cb19-494" aria-hidden="true" tabindex="-1"></a><span class="ot">[^2]: </span>That hasn't always been the DST rule, but it's been the case for as long as r/c has existed</span>
<span id="cb19-495"><a href="#cb19-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-496"><a href="#cb19-496" aria-hidden="true" tabindex="-1"></a><span class="ot">[^3]: </span>The two scores behave similarly, with the exception that for the consistency score, we'd expected DST to show up as a dip at zero, rather than a peak.</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">
        <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="./about.html">About</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/cutonbuminband/rcounting">Github</a>
  </li>  
</ul>
      </div>
  </div>
</footer>



</body></html>