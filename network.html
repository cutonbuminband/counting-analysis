<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>rcounting - The r/counting network</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title">The r/counting network</h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">rcounting</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle sidebar-tool" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">Analysis</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Analysing rcounting data</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./separators.html" class="sidebar-item-text sidebar-link">The use of separators</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./runs.html" class="sidebar-item-text sidebar-link">Longest runs</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./network.html" class="sidebar-item-text sidebar-link active">The r/counting network</a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./examples.html" class="sidebar-item-text sidebar-link">Examples</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-rcounting-relationship-graph" id="toc-the-rcounting-relationship-graph" class="nav-link active" data-scroll-target="#the-rcounting-relationship-graph">The r/counting relationship graph</a>
  <ul class="collapse">
  <li><a href="#cliques" id="toc-cliques" class="nav-link" data-scroll-target="#cliques">Cliques</a></li>
  </ul></li>
  <li><a href="#visualising-the-rcounting-graph" id="toc-visualising-the-rcounting-graph" class="nav-link" data-scroll-target="#visualising-the-rcounting-graph">Visualising the r/counting graph</a>
  <ul class="collapse">
  <li><a href="#the-core-of-the-rcounting-graph" id="toc-the-core-of-the-rcounting-graph" class="nav-link" data-scroll-target="#the-core-of-the-rcounting-graph">The core of the r/counting graph</a>
  <ul class="collapse">
  <li><a href="#the-weighted-core" id="toc-the-weighted-core" class="nav-link" data-scroll-target="#the-weighted-core">The weighted core</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title d-none d-lg-block">The r/counting network</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>One of the interesting things we can look at using the counting data is the relationships between different counters. For example, and as an introduction, we can ask which counters have replied to each other most often</p>
<div class="cell" data-execution_count="1">
<details>
<summary>Code for importing packages and loading data</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sqlite3</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> rcounting <span class="im">import</span> counters, analysis, graph_tools</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>sns.set_theme()</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>data_directory <span class="op">=</span> Path(<span class="st">"../data"</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>db <span class="op">=</span> sqlite3.<span class="ex">connect</span>(data_directory <span class="op">/</span> <span class="st">"counting.sqlite"</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>counts <span class="op">=</span> pd.read_sql(<span class="st">"select username from comments where position &gt; 0 order by timestamp"</span>, db)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>counts[<span class="st">"username"</span>] <span class="op">=</span> counts[<span class="st">"username"</span>].<span class="bu">apply</span>(counters.apply_alias)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><a href="#tbl-best-friends">Table&nbsp;1</a> shows the 10 pairs of counters who have replied directly to each other most often. Evidently it’s more likely that someone will appear in the table if they’ve made a lot of counts, but it’s still interesting to see that the top spot isn’t held by the top two counters.</p>
<div class="cell" data-execution_count="2">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> analysis.response_graph(counts, <span class="dv">1000</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>graph.columns <span class="op">=</span> [<span class="st">'source'</span>, <span class="st">'target'</span>, <span class="st">'weight'</span>]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>DG <span class="op">=</span> nx.DiGraph(graph)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>DG.remove_edges_from(nx.selfloop_edges(DG))</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> graph_tools.symmetrize(DG)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> pd.DataFrame(G.edges(data<span class="op">=</span><span class="va">True</span>), columns<span class="op">=</span>[<span class="st">'user1'</span>, <span class="st">'user2'</span>, <span class="st">'weight'</span>])</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>edges[<span class="st">'weight'</span>] <span class="op">=</span> edges[<span class="st">'weight'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: x[<span class="st">'weight'</span>])</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>Markdown(edges.sort_values(by<span class="op">=</span><span class="st">'weight'</span>, ascending<span class="op">=</span><span class="va">False</span>).head(<span class="dv">10</span>).to_markdown(index<span class="op">=</span><span class="va">False</span>, headers<span class="op">=</span>[<span class="st">"**Counter 1**"</span>, <span class="st">"**Counter 2**"</span>, <span class="st">"**Total number of replies**"</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="2">
<div id="tbl-best-friends" class="anchored">
<table class="table table-sm table-striped">
<caption>Table&nbsp;1: The counters who have replied to each other most often.</caption>
<colgroup>
<col style="width: 25%">
<col style="width: 30%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Counter 1</strong></th>
<th style="text-align: left;"><strong>Counter 2</strong></th>
<th style="text-align: right;"><strong>Total number of replies</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">thephilsblogbar2</td>
<td style="text-align: left;">GarlicoinAccount</td>
<td style="text-align: right;">197665</td>
</tr>
<tr class="even">
<td style="text-align: left;">Countletics</td>
<td style="text-align: left;">nonsensy</td>
<td style="text-align: right;">185844</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Antichess</td>
<td style="text-align: left;">Countletics</td>
<td style="text-align: right;">144979</td>
</tr>
<tr class="even">
<td style="text-align: left;">Countletics</td>
<td style="text-align: left;">davidjl123</td>
<td style="text-align: right;">73256</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Antichess</td>
<td style="text-align: left;">Trial-Name</td>
<td style="text-align: right;">70385</td>
</tr>
<tr class="even">
<td style="text-align: left;">Countletics</td>
<td style="text-align: left;">thephilsblogbar2</td>
<td style="text-align: right;">68797</td>
</tr>
<tr class="odd">
<td style="text-align: left;">thephilsblogbar2</td>
<td style="text-align: left;">ClockButTakeOutTheL</td>
<td style="text-align: right;">68392</td>
</tr>
<tr class="even">
<td style="text-align: left;">Countletics</td>
<td style="text-align: left;">qwertylool</td>
<td style="text-align: right;">67484</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Ezekiel134</td>
<td style="text-align: left;">davidjl123</td>
<td style="text-align: right;">44820</td>
</tr>
<tr class="even">
<td style="text-align: left;">Countletics</td>
<td style="text-align: left;">Smartstocks</td>
<td style="text-align: right;">41656</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<section id="the-rcounting-relationship-graph" class="level1">
<h1>The r/counting relationship graph</h1>
<p>If we go into a bit more detail, what we really want to look at is the <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">graph</a> of the r/counting community. We can represent each person as a node, and two nodes are connected if one of them has replied to the other. The weight of each connection is the number of times each person has replied to the other.</p>
<p>Moving from a representation centering individual counts to one focussing on the relationship between pairs of counters lets us ask and answer some interesting questions.</p>
<p>A natural question to ask is what is the <strong>diameter</strong> of the graph: that is, what is the smallest number of links, <span class="math inline">\(D\)</span>, such that every counter is connected to every other in <span class="math inline">\(D\)</span> links or fewer. To answer this and every other graph question, we’ll make use of the <a href="https://networkx.org/documentation/stable/">networkx</a> library.</p>
<div class="cell" data-execution_count="3">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The diameter is </span><span class="sc">{</span>nx<span class="sc">.</span>diameter(G)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The diameter is 4</code></pre>
</div>
</div>
<p>That means that every counter in the top 1000 counters is at most four links away from every other node.</p>
<p>Instead of the diameter, we can also ask about the <strong>radius</strong> of the graph. This is defined as the smallest number of links, <span class="math inline">\(R\)</span>, such that <em>at least one</em> counter is connected to every other in <span class="math inline">\(R\)</span> links or fewer. You should be able to convince yourself that <span class="math inline">\(D \leq 2R\)</span>.</p>
<div class="cell" data-execution_count="4">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The radius is </span><span class="sc">{</span>nx<span class="sc">.</span>radius(G)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The radius is 2</code></pre>
</div>
</div>
<p>And in fact we see that there are counters that can reach every other count in 2 links or fewer. These counters are the center of the graph, and we can see who they are:</p>
<div class="cell" data-execution_count="5">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"There are </span><span class="sc">{</span><span class="bu">len</span>(nx.center(G))<span class="sc">}</span><span class="ss"> counters in the center of the graph. They are:</span><span class="ch">\n\n</span><span class="ss">- "</span><span class="op">+</span> <span class="st">", "</span>.join(nx.center(G)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="5">
<p>There are 14 counters in the center of the graph. They are:</p>
<ul>
<li>Ezekiel134, Maniac_34, Mooraell, RandomRedditorWithNo, Removedpixel, Smartstocks, TehVulpez, TheNitromeFan, Urbul, atomicimploder, davidjl123, dominodan123, kdiuro13, rideride</li>
</ul>
</div>
</div>
<p>To get a feel for just how connected the graph is, we can calculate two more things. The first is the size of the biggest group such that ever counter is connected to every other counter in the group via three links or fewer.</p>
<div class="cell" data-execution_count="6">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cvxopt</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> cvxopt <span class="im">import</span> matrix, glpk</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>glpk.options[<span class="st">'msg_lev'</span>] <span class="op">=</span> <span class="st">'GLP_MSG_OFF'</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>paths <span class="op">=</span> scipy.sparse.csgraph.floyd_warshall(nx.to_numpy_array(G), directed<span class="op">=</span><span class="va">False</span>, unweighted<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> group_size(paths, k):</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> np.where(np.triu(paths) <span class="op">&gt;</span> k)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    constraints <span class="op">=</span> np.zeros((<span class="bu">len</span>(rows), <span class="bu">len</span>(G)))</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx, (row, col) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(rows, cols)):</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        constraints[idx][row] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        constraints[idx][col] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    conflicts <span class="op">=</span> np.ones(<span class="bu">len</span>(rows))</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    goal <span class="op">=</span> <span class="op">-</span>np.ones(<span class="bu">len</span>(G))</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    status, x <span class="op">=</span> glpk.ilp(matrix(goal), matrix(constraints), matrix(conflicts), B<span class="op">=</span><span class="bu">set</span>(<span class="bu">range</span>(<span class="bu">len</span>(G))))</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">int</span>(<span class="bu">sum</span>(x))</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"There is a group of </span><span class="sc">{</span>group_size(paths, k)<span class="sc">}</span><span class="ss"> counters that can all be reached within </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> links or fewer"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="6">
<p>There is a group of 997 counters that can all be reached within 3 links or fewer</p>
</div>
</div>
<p>That’s basically everyone in the top 1000.</p>
<p>And for two counters the number is</p>
<div class="cell" data-execution_count="7">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>group_size(paths, <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>719</code></pre>
</div>
</div>
<p>which is still quite sizeable.</p>
<section id="cliques" class="level3">
<h3 class="anchored" data-anchor-id="cliques">Cliques</h3>
<p>Moving down to shorter and shorter links, we can look at groups such that every counter in the group is directly connected to every other[^1]. These are known as <em>cliques</em> in the graph world. We can use <code>networkx</code> to easily calculate the size of the largest clique, and some more information about them</p>
<div class="cell" data-execution_count="8">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> functools</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>cliques <span class="op">=</span> <span class="bu">list</span>(nx.find_cliques(G))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>clique_number <span class="op">=</span> nx.graph_clique_number(G, cliques)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>maximum_cliques <span class="op">=</span> [clique <span class="cf">for</span> clique <span class="kw">in</span> cliques <span class="cf">if</span> <span class="bu">len</span>(clique) <span class="op">==</span> clique_number]</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> (<span class="ss">f"The largest clique has size </span><span class="sc">{</span>clique_number<span class="sc">}</span><span class="ss"> and there are </span><span class="sc">{</span><span class="bu">len</span>(maximum_cliques)<span class="sc">}</span><span class="ss"> such groups.</span><span class="ch">\n\n</span><span class="ss">"</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>counters <span class="op">=</span> functools.<span class="bu">reduce</span>(<span class="kw">lambda</span> x, y: <span class="bu">set</span>(x) <span class="op">|</span> <span class="bu">set</span>(y), maximum_cliques)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>s <span class="op">+=</span> (<span class="ss">f"The following </span><span class="sc">{</span><span class="bu">len</span>(counters)<span class="sc">}</span><span class="ss"> counters appear in at least one clique:</span><span class="ch">\n\n</span><span class="ss"> - "</span> <span class="op">+</span> <span class="st">", "</span>.join(<span class="bu">list</span>(counters)) <span class="op">+</span> <span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>unique_counters <span class="op">=</span> functools.<span class="bu">reduce</span>(<span class="kw">lambda</span> x, y: <span class="bu">set</span>(x) <span class="op">&amp;</span> <span class="bu">set</span>(y), maximum_cliques)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>s <span class="op">+=</span> (<span class="ss">f"And the following </span><span class="sc">{</span><span class="bu">len</span>(unique_counters)<span class="sc">}</span><span class="ss"> counters appear in every clique:</span><span class="ch">\n\n</span><span class="ss"> - "</span> <span class="op">+</span> <span class="st">", "</span>.join(<span class="bu">list</span>(unique_counters)) <span class="op">+</span> <span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>examples <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c1, c2 <span class="kw">in</span> itertools.combinations(maximum_cliques, <span class="dv">2</span>):</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> <span class="bu">set</span>(c1) <span class="op">^</span> <span class="bu">set</span>(c2)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(d) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        examples <span class="op">|=</span> <span class="bu">set</span>([<span class="bu">tuple</span>(<span class="bu">sorted</span>(d))])</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>s <span class="op">+=</span> <span class="ss">f"To get a </span><span class="sc">{</span>clique_number <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">-clique, any of the following people would have to count together:</span><span class="ch">\n\n</span><span class="ss">- "</span> <span class="op">+</span> <span class="st">"</span><span class="ch">\n</span><span class="st">- "</span>.join(<span class="st">" and "</span>.join(y) <span class="cf">for</span> y <span class="kw">in</span> examples)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>Markdown(s)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="8">
<p>The largest clique has size 35 and there are 18 such groups.</p>
<p>The following 44 counters appear in at least one clique:</p>
<ul>
<li>kdiuro13, MrUnderdawg, a-username-for-me, overturned-rock, PaleRepresentative, -R3DF0X, qwertylool, Smartstocks, Countletics, timo78888, The_Nepenthe, CutOnBumInBandHere9, nonsensy, Mooraell, TehVulpez, TheNitromeFan, Cox_1920, NeonTaterTots, Zaajdaeon, davidjl123, GarlicoinAccount, padiwik, thephilsblogbar2, Juqu, NobodyL0vesMe, atomicimploder, Ezekiel134, noduorg, foxthechicken, amazingpikachu_38, Trial-Name, FartyMcNarty, AlienApricot, llamasR5life, dominodan123, treje, AxelC77, Antichess, Tornado9797, 4everNdeavor, Nekyiia, mistyskye14, davockx, Urbul</li>
</ul>
<p>And the following 27 counters appear in every clique:</p>
<ul>
<li>kdiuro13, MrUnderdawg, a-username-for-me, PaleRepresentative, noduorg, -R3DF0X, qwertylool, Smartstocks, Countletics, timo78888, llamasR5life, dominodan123, Antichess, nonsensy, Mooraell, TehVulpez, TheNitromeFan, Cox_1920, Zaajdaeon, davidjl123, GarlicoinAccount, thephilsblogbar2, NobodyL0vesMe, mistyskye14, atomicimploder, Urbul, Ezekiel134</li>
</ul>
<p>To get a 36-clique, any of the following people would have to count together:</p>
<ul>
<li>AxelC77 and Juqu</li>
<li>NeonTaterTots and foxthechicken</li>
<li>Nekyiia and overturned-rock</li>
<li>CutOnBumInBandHere9 and davockx</li>
<li>4everNdeavor and Trial-Name</li>
<li>AxelC77 and amazingpikachu_38</li>
<li>The_Nepenthe and padiwik</li>
<li>AlienApricot and FartyMcNarty</li>
<li>Tornado9797 and treje</li>
</ul>
</div>
</div>
<p>I’m sure it’ll happen eventually!</p>
</section>
</section>
<section id="visualising-the-rcounting-graph" class="level1 page-columns page-full">
<h1>Visualising the r/counting graph</h1>
<p>The above summary statistics are nice, but it would be even nicer if we could visualize the structure of the counting graph.</p>
<p>That requires some way of placing nodes and edges in space, since a priori there is no spatial information in the graph.</p>
<p>The nice creators of the <a href="">gephi</a> software package have developed an excellent approach for this. The idea is that we can make nodes repel each other, and edges between nodes attract like springs, and then run the algorithm until the nodes find some equilibrium position. The result of this is that users with many total counts will be spread throughout the graph, and pairs of users who have counted a lot with each other will be relatively close</p>
<p>When I do that on the counting graph, I get the structure seen on <a href="#fig-both">Figure&nbsp;1</a></p>
<div class="column-page-inset">
<div id="fig-both" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="figures/both.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;1: The graph of the r/counting community, arranged according to the ForceAtlas 2 algorithm. The two colours are a partition of the graph into two communities</figcaption><p></p>
</figure>
</div>
</div>
<div class="page-columns page-full"><p>The colour corresponds to which community a given node belongs to, when using the <a href="https://sourceforge.net/projects/louvain/">Louvain method for community detection</a> and adjusting the parameters so that only two communities appear<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. This is a completely different approach to the one used to arrange the graph, so it’s interesting to see that there is fairly good spatial separation between the two colours.</p><div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;This means that 2 probably isn’t the best number for the total number of distinct communities in the graph; a higher number would probably be better. Instead, what it means is that if you have to assign one of two colours to each node, this is a good way of doing it.</p></li></div></div>
<div id="fig-colours" class="quarto-figure quarto-figure-center column-screen-inset anchored">
<figure class="figure">
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="figures/pink.svg" class="img-fluid figure-img"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="figures/blue.svg" class="img-fluid figure-img"></p>
</div>
</div>
</div>
<p></p><figcaption class="figure-caption">Figure&nbsp;2: The counters of respectively the pink and blue communities. The charts are vector graphics, so you should be able to view them in a separate tab and zoom in as much as you like.</figcaption><p></p>
</figure>
</div>
<p>We know the usernames of the counters in each community, and they are shown on <a href="#fig-colours">Figure&nbsp;2</a>. Looking at them, it seems that what it mainly picks up is the era when people were active, where pink is older users, and blue is newer ones. Certainly for my case I’m far more familiar with the green counters than with the pink, so it makes sense that I ended up on the blue team. It also makes sense that the top counters ended up more or less in the middle of the graph.</p>
<p>I hope we can all wear these badges with pride and use them to hate on the other team #goblues.</p>
<section id="the-core-of-the-rcounting-graph" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="the-core-of-the-rcounting-graph">The core of the r/counting graph</h2>
<p>The counting community has evolved over time, with new people dropping in, and older counters fading away (and sometimes staging <a href="./index.html#tbl-oldest-counters">remarkable comebacks</a>).</p>
<p>In the counting graph, one person is connected to another if they’ve ever replied to each another. The <strong>degree</strong> of a person is a count of how many connections they have. There’s a really neat approach to finding the most connected group of people in the graph that goes as follows:</p>
<ul>
<li>Define the connectivity score of the graph as the degree of the least-connected person in the graph</li>
<li>Remove the least-connected person in the graph and see what happens to the connectivity score</li>
<li>Keep going until the connectivity score starts to decrease.</li>
</ul>
<p>When you remove one person, you do to things that might affect the overall connectivity score:</p>
<ul>
<li>You remove the least-connected person, so in everyone that remains is at least as well connected as that person, and possibly more connected</li>
<li>You decrease the degree of everyone that was directly connected to the least-connected person, possibly causing the overall connectivity score to decrease.</li>
</ul>
<p>Doing that for the counting graph we get</p>
<div class="cell" data-execution_count="9">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> networkx.algorithms.core <span class="im">import</span> core_number</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>core <span class="op">=</span> core_number(G)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>max_core <span class="op">=</span> <span class="bu">max</span>(core.values())</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>unweighted_core <span class="op">=</span> [key <span class="cf">for</span> key <span class="kw">in</span> core.keys() <span class="cf">if</span> core[key] <span class="op">==</span> <span class="bu">max</span>(core.values())]</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"There are </span><span class="sc">{</span><span class="bu">len</span>(unweighted_core)<span class="sc">}</span><span class="ss"> counters in the unweighted core."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="9">
<p>There are 115 counters in the unweighted core.</p>
</div>
</div>
<section id="the-weighted-core" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="the-weighted-core">The weighted core</h3>
<p>The approach I’ve just described has an important flaw in that it completely ignores how often two counters have interacted, and only looks at whether they are connected. That means that the connection between two counters who have only one count together is given the same importance as the connection between the counters in <a href="#tbl-best-friends">Table&nbsp;1</a>. That seems unfortunate.</p>
<p>One way of proceeding would be to apply a threshold and only link two counters in the graph if they have counted together more than X times. That gets rid of the “One count is equivalent to arbitrarily many counts” issue, but isn’t very satisfactory - instead, we get “X - 1 counts is equivalent to 0”, and “X counts is equivalent to arbitrarily many”.</p>
<p>A better way would be if the strength of the connection could be incorporated into the calculation of the core. I’ll spare you the details, but doing so is a bit tricky. When the network is unweighted, there is a fast algorithm for finding the core <span class="citation" data-cites="batagelj2003om">(<a href="#ref-batagelj2003om" role="doc-biblioref">Batagelj and Zaversnik 2003</a>)</span>, but adding weights breaks that algorithm. I ended up implementing it myself, you can see the implementation <a href="https://github.com/cutonbuminband/rcounting/blob/main/rcounting/graph_tools.py#LL41">here</a> if you want.</p>
<div class="no-row-height column-margin column-container"><div id="ref-batagelj2003om" class="csl-entry" role="doc-biblioentry">
Batagelj, V., and M. Zaversnik. 2003. <span>“An o(m) Algorithm for Cores Decomposition of Networks.”</span> <a href="https://arxiv.org/abs/cs/0310049">https://arxiv.org/abs/cs/0310049</a>.
</div></div><p>Once I have a method for taking into account the weighted degree of each node, there are two questions to consider:</p>
<ol type="1">
<li>How to model the strength of a single connection</li>
<li>How to model the total weight of a node, based on the strength of all the connections it has with other nodes</li>
</ol>
<p>The first question is absolutely vital to ask. If the strength of a connection between two counters is defined as just the total number of counts they have together, then no matter what else I do, the core ends up consisting of very few people who all have a lot of counts together.</p>
<div class="cell" data-execution_count="10">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>coreness <span class="op">=</span> graph_tools.weighted_core_number(G, p<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>max_core_value <span class="op">=</span> <span class="bu">max</span>(coreness.values())</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>unscaled_core <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> core <span class="cf">if</span> coreness[x] <span class="op">==</span> max_core_value]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="ss">f"There are </span><span class="sc">{</span><span class="bu">len</span>(unscaled_core)<span class="sc">}</span><span class="ss"> counters in the core. They are:</span><span class="ch">\n\n</span><span class="ss"> - "</span> <span class="op">+</span> <span class="st">"</span><span class="ch">\n</span><span class="st">- "</span>.join(unscaled_core)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>Markdown(s)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="10">
<p>There are 4 counters in the core. They are:</p>
<ul>
<li>Countletics</li>
<li>nonsensy</li>
<li>thephilsblogbar2</li>
<li>GarlicoinAccount</li>
</ul>
</div>
</div>
<p>A choice that works fairly well is to model the strength of the connection as the logarithm of the total number of counts. That lets more intense connections have more importance, but within reason.</p>
<p>The second question is a bit more subtle, since there’s an intuitive choice that works fairly well, namely just using the sum of all the connection strengths. But that’s not the only way to do things. In the end I ended up taking a weighted combination of the degree of the node and the total connection strength, so that the weighted degree of node <span class="math inline">\(i\)</span>, <span class="math inline">\(k'_{i}\)</span> is given by</p>
<p><span class="math display">\[
k'_{i}= \left(k_{i}\right)^{1 - p} \left(\sum _{\textrm{neighbors} j}{w_{ij}}\right)^{p}
\]</span></p>
<p>where the sum runs over all neighbors <span class="math inline">\(j\)</span> of node <span class="math inline">\(i\)</span>, <span class="math inline">\(w_{ij}\)</span> is the strength of the connection between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, and <span class="math inline">\(p\)</span> is a parameter I choose that varies between <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>. Setting <span class="math inline">\(p = 0\)</span> means that only the unweighted degree of the node is considered, while setting <span class="math inline">\(p = 1\)</span> means that only the sum of connection strengths matters. In between, you get a mix.</p>
<div class="cell" data-execution_count="11">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>graph_tools.scale_weights(G)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>coreness <span class="op">=</span> graph_tools.weighted_core_number(G, p<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>max_core_value <span class="op">=</span> <span class="bu">max</span>(coreness.values())</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>weighted_core <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> core <span class="cf">if</span> coreness[x] <span class="op">==</span> max_core_value]</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>nx.set_node_attributes(G, <span class="st">"periphery"</span>, name<span class="op">=</span><span class="st">"k-core"</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>nx.set_node_attributes(G.subgraph(weighted_core), <span class="st">"core"</span>, name<span class="op">=</span><span class="st">"k-core"</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>nx.write_gexf(G, <span class="st">"../data/graph.gexf"</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="ss">f"There are </span><span class="sc">{</span><span class="bu">len</span>(weighted_core)<span class="sc">}</span><span class="ss"> counters in the weighted core."</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>Markdown(s)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="11">
<p>There are 95 counters in the weighted core.</p>
</div>
</div>
<p>This is a slightly smaller number then counters who were in the core for the unweighted case, and there’s also some difference in the composition of the members that remain:</p>
<div class="cell" data-execution_count="12">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"There are </span><span class="sc">{</span><span class="bu">len</span>(<span class="bu">set</span>(weighted_core) <span class="op">^</span> <span class="bu">set</span>(unweighted_core))<span class="sc">}</span><span class="ss"> present in only one of the weighted or unweighted core."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="12">
<p>There are 28 present in only one of the weighted or unweighted core.</p>
</div>
</div>
<p>With the core in hand, it’s possible to visualise the counting graph again, this time highlighting the members of the weighted core, as shown on <a href="#fig-core">Figure&nbsp;3</a></p>
<div id="fig-core" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="figures/core.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;3: The ~100 core members of the counting graph highlighted in green</figcaption><p></p>
</figure>
</div>
<p>Interestingly enough the core mainly seems to correspond to the blue team shown on <a href="#fig-both">Figure&nbsp;1</a>, so perhaps my earlier suggestion that the colours mainly correspond to age is incorrect.</p>


<!-- -->


</section>
</section>
</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb16" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "The r/counting network"</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>One of the interesting things we can look at using the counting data is the relationships between different counters. For example, and as an introduction, we can ask which counters have replied to each other most often</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Code for importing packages and loading data"</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sqlite3</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> rcounting <span class="im">import</span> counters, analysis, graph_tools</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>sns.set_theme()</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>data_directory <span class="op">=</span> Path(<span class="st">"../data"</span>)</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>db <span class="op">=</span> sqlite3.<span class="ex">connect</span>(data_directory <span class="op">/</span> <span class="st">"counting.sqlite"</span>)</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>counts <span class="op">=</span> pd.read_sql(<span class="st">"select username from comments where position &gt; 0 order by timestamp"</span>, db)</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>counts[<span class="st">"username"</span>] <span class="op">=</span> counts[<span class="st">"username"</span>].<span class="bu">apply</span>(counters.apply_alias)</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>@tbl-best-friends shows the 10 pairs of counters who have replied directly to each other most often. Evidently it's more likely that someone will appear in the table if they've made a lot of counts, but it's still interesting to see that the top spot isn't held by the top two counters.</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-best-friends</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: The counters who have replied to each other most often.</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> analysis.response_graph(counts, <span class="dv">1000</span>)</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>graph.columns <span class="op">=</span> [<span class="st">'source'</span>, <span class="st">'target'</span>, <span class="st">'weight'</span>]</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>DG <span class="op">=</span> nx.DiGraph(graph)</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>DG.remove_edges_from(nx.selfloop_edges(DG))</span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> graph_tools.symmetrize(DG)</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> pd.DataFrame(G.edges(data<span class="op">=</span><span class="va">True</span>), columns<span class="op">=</span>[<span class="st">'user1'</span>, <span class="st">'user2'</span>, <span class="st">'weight'</span>])</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>edges[<span class="st">'weight'</span>] <span class="op">=</span> edges[<span class="st">'weight'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: x[<span class="st">'weight'</span>])</span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>Markdown(edges.sort_values(by<span class="op">=</span><span class="st">'weight'</span>, ascending<span class="op">=</span><span class="va">False</span>).head(<span class="dv">10</span>).to_markdown(index<span class="op">=</span><span class="va">False</span>, headers<span class="op">=</span>[<span class="st">"**Counter 1**"</span>, <span class="st">"**Counter 2**"</span>, <span class="st">"**Total number of replies**"</span>]))</span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a><span class="fu"># The r/counting relationship graph</span></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>If we go into a bit more detail, what we really want to look at is the <span class="co">[</span><span class="ot">graph</span><span class="co">](https://en.wikipedia.org/wiki/Graph_\(discrete_mathematics\))</span> of the r/counting community. We can represent each person as a node, and two nodes are connected if one of them has replied to the other. The weight of each connection is the number of times each person has replied to the other.</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>Moving from a representation centering individual counts to one focussing on the relationship between pairs of counters lets us ask and answer some interesting questions.</span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>A natural question to ask is what is the **diameter** of the graph: that is, what is the smallest number of links, $D$, such that every counter is connected to every other in $D$ links or fewer. To answer this and every other graph question, we'll make use of the <span class="co">[</span><span class="ot">networkx</span><span class="co">](https://networkx.org/documentation/stable/)</span> library.</span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The diameter is </span><span class="sc">{</span>nx<span class="sc">.</span>diameter(G)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a>That means that every counter in the top 1000 counters is at most four links away from every other node.</span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>Instead of the diameter, we can also ask about the **radius** of the graph. This is defined as the smallest number of links, $R$, such that *at least one* counter is connected to every other in $R$ links or fewer. You should be able to convince yourself that $D \leq 2R$.</span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The radius is </span><span class="sc">{</span>nx<span class="sc">.</span>radius(G)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-69"><a href="#cb16-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-70"><a href="#cb16-70" aria-hidden="true" tabindex="-1"></a>And in fact we see that there are counters that can reach every other count in 2 links or fewer. These counters are the center of the graph, and we can see who they are:</span>
<span id="cb16-71"><a href="#cb16-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-74"><a href="#cb16-74" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb16-75"><a href="#cb16-75" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"There are </span><span class="sc">{</span><span class="bu">len</span>(nx.center(G))<span class="sc">}</span><span class="ss"> counters in the center of the graph. They are:</span><span class="ch">\n\n</span><span class="ss">- "</span><span class="op">+</span> <span class="st">", "</span>.join(nx.center(G)))</span>
<span id="cb16-76"><a href="#cb16-76" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-77"><a href="#cb16-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-78"><a href="#cb16-78" aria-hidden="true" tabindex="-1"></a>To get a feel for just how connected the graph is, we can calculate two more things. The first is the size of the biggest group such that ever counter is connected to every other counter in the group via three links or fewer.</span>
<span id="cb16-79"><a href="#cb16-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-80"><a href="#cb16-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-83"><a href="#cb16-83" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb16-84"><a href="#cb16-84" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy</span>
<span id="cb16-85"><a href="#cb16-85" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cvxopt</span>
<span id="cb16-86"><a href="#cb16-86" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> cvxopt <span class="im">import</span> matrix, glpk</span>
<span id="cb16-87"><a href="#cb16-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-88"><a href="#cb16-88" aria-hidden="true" tabindex="-1"></a>glpk.options[<span class="st">'msg_lev'</span>] <span class="op">=</span> <span class="st">'GLP_MSG_OFF'</span></span>
<span id="cb16-89"><a href="#cb16-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-90"><a href="#cb16-90" aria-hidden="true" tabindex="-1"></a>paths <span class="op">=</span> scipy.sparse.csgraph.floyd_warshall(nx.to_numpy_array(G), directed<span class="op">=</span><span class="va">False</span>, unweighted<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-91"><a href="#cb16-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-92"><a href="#cb16-92" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> group_size(paths, k):</span>
<span id="cb16-93"><a href="#cb16-93" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> np.where(np.triu(paths) <span class="op">&gt;</span> k)</span>
<span id="cb16-94"><a href="#cb16-94" aria-hidden="true" tabindex="-1"></a>    constraints <span class="op">=</span> np.zeros((<span class="bu">len</span>(rows), <span class="bu">len</span>(G)))</span>
<span id="cb16-95"><a href="#cb16-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx, (row, col) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(rows, cols)):</span>
<span id="cb16-96"><a href="#cb16-96" aria-hidden="true" tabindex="-1"></a>        constraints[idx][row] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb16-97"><a href="#cb16-97" aria-hidden="true" tabindex="-1"></a>        constraints[idx][col] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb16-98"><a href="#cb16-98" aria-hidden="true" tabindex="-1"></a>    conflicts <span class="op">=</span> np.ones(<span class="bu">len</span>(rows))</span>
<span id="cb16-99"><a href="#cb16-99" aria-hidden="true" tabindex="-1"></a>    goal <span class="op">=</span> <span class="op">-</span>np.ones(<span class="bu">len</span>(G))</span>
<span id="cb16-100"><a href="#cb16-100" aria-hidden="true" tabindex="-1"></a>    status, x <span class="op">=</span> glpk.ilp(matrix(goal), matrix(constraints), matrix(conflicts), B<span class="op">=</span><span class="bu">set</span>(<span class="bu">range</span>(<span class="bu">len</span>(G))))</span>
<span id="cb16-101"><a href="#cb16-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">int</span>(<span class="bu">sum</span>(x))</span>
<span id="cb16-102"><a href="#cb16-102" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb16-103"><a href="#cb16-103" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"There is a group of </span><span class="sc">{</span>group_size(paths, k)<span class="sc">}</span><span class="ss"> counters that can all be reached within </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> links or fewer"</span>)</span>
<span id="cb16-104"><a href="#cb16-104" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-105"><a href="#cb16-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-106"><a href="#cb16-106" aria-hidden="true" tabindex="-1"></a>That's basically everyone in the top 1000.</span>
<span id="cb16-107"><a href="#cb16-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-108"><a href="#cb16-108" aria-hidden="true" tabindex="-1"></a>And for two counters the number is</span>
<span id="cb16-111"><a href="#cb16-111" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb16-112"><a href="#cb16-112" aria-hidden="true" tabindex="-1"></a>group_size(paths, <span class="dv">2</span>)</span>
<span id="cb16-113"><a href="#cb16-113" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-114"><a href="#cb16-114" aria-hidden="true" tabindex="-1"></a>which is still quite sizeable.</span>
<span id="cb16-115"><a href="#cb16-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-116"><a href="#cb16-116" aria-hidden="true" tabindex="-1"></a><span class="fu">### Cliques</span></span>
<span id="cb16-117"><a href="#cb16-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-118"><a href="#cb16-118" aria-hidden="true" tabindex="-1"></a>Moving down to shorter and shorter links, we can look at groups such that every counter in the group is directly connected to every other<span class="ot">[^1]</span>. These are known as *cliques* in the graph world. We can use <span class="in">`networkx`</span> to easily calculate the size of the largest clique, and some more information about them</span>
<span id="cb16-119"><a href="#cb16-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-122"><a href="#cb16-122" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb16-123"><a href="#cb16-123" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> functools</span>
<span id="cb16-124"><a href="#cb16-124" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb16-125"><a href="#cb16-125" aria-hidden="true" tabindex="-1"></a>cliques <span class="op">=</span> <span class="bu">list</span>(nx.find_cliques(G))</span>
<span id="cb16-126"><a href="#cb16-126" aria-hidden="true" tabindex="-1"></a>clique_number <span class="op">=</span> nx.graph_clique_number(G, cliques)</span>
<span id="cb16-127"><a href="#cb16-127" aria-hidden="true" tabindex="-1"></a>maximum_cliques <span class="op">=</span> [clique <span class="cf">for</span> clique <span class="kw">in</span> cliques <span class="cf">if</span> <span class="bu">len</span>(clique) <span class="op">==</span> clique_number]</span>
<span id="cb16-128"><a href="#cb16-128" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> (<span class="ss">f"The largest clique has size </span><span class="sc">{</span>clique_number<span class="sc">}</span><span class="ss"> and there are </span><span class="sc">{</span><span class="bu">len</span>(maximum_cliques)<span class="sc">}</span><span class="ss"> such groups.</span><span class="ch">\n\n</span><span class="ss">"</span>)</span>
<span id="cb16-129"><a href="#cb16-129" aria-hidden="true" tabindex="-1"></a>counters <span class="op">=</span> functools.<span class="bu">reduce</span>(<span class="kw">lambda</span> x, y: <span class="bu">set</span>(x) <span class="op">|</span> <span class="bu">set</span>(y), maximum_cliques)</span>
<span id="cb16-130"><a href="#cb16-130" aria-hidden="true" tabindex="-1"></a>s <span class="op">+=</span> (<span class="ss">f"The following </span><span class="sc">{</span><span class="bu">len</span>(counters)<span class="sc">}</span><span class="ss"> counters appear in at least one clique:</span><span class="ch">\n\n</span><span class="ss"> - "</span> <span class="op">+</span> <span class="st">", "</span>.join(<span class="bu">list</span>(counters)) <span class="op">+</span> <span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb16-131"><a href="#cb16-131" aria-hidden="true" tabindex="-1"></a>unique_counters <span class="op">=</span> functools.<span class="bu">reduce</span>(<span class="kw">lambda</span> x, y: <span class="bu">set</span>(x) <span class="op">&amp;</span> <span class="bu">set</span>(y), maximum_cliques)</span>
<span id="cb16-132"><a href="#cb16-132" aria-hidden="true" tabindex="-1"></a>s <span class="op">+=</span> (<span class="ss">f"And the following </span><span class="sc">{</span><span class="bu">len</span>(unique_counters)<span class="sc">}</span><span class="ss"> counters appear in every clique:</span><span class="ch">\n\n</span><span class="ss"> - "</span> <span class="op">+</span> <span class="st">", "</span>.join(<span class="bu">list</span>(unique_counters)) <span class="op">+</span> <span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb16-133"><a href="#cb16-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-134"><a href="#cb16-134" aria-hidden="true" tabindex="-1"></a>examples <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb16-135"><a href="#cb16-135" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c1, c2 <span class="kw">in</span> itertools.combinations(maximum_cliques, <span class="dv">2</span>):</span>
<span id="cb16-136"><a href="#cb16-136" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> <span class="bu">set</span>(c1) <span class="op">^</span> <span class="bu">set</span>(c2)</span>
<span id="cb16-137"><a href="#cb16-137" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(d) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb16-138"><a href="#cb16-138" aria-hidden="true" tabindex="-1"></a>        examples <span class="op">|=</span> <span class="bu">set</span>([<span class="bu">tuple</span>(<span class="bu">sorted</span>(d))])</span>
<span id="cb16-139"><a href="#cb16-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-140"><a href="#cb16-140" aria-hidden="true" tabindex="-1"></a>s <span class="op">+=</span> <span class="ss">f"To get a </span><span class="sc">{</span>clique_number <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">-clique, any of the following people would have to count together:</span><span class="ch">\n\n</span><span class="ss">- "</span> <span class="op">+</span> <span class="st">"</span><span class="ch">\n</span><span class="st">- "</span>.join(<span class="st">" and "</span>.join(y) <span class="cf">for</span> y <span class="kw">in</span> examples)</span>
<span id="cb16-141"><a href="#cb16-141" aria-hidden="true" tabindex="-1"></a>Markdown(s)</span>
<span id="cb16-142"><a href="#cb16-142" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-143"><a href="#cb16-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-144"><a href="#cb16-144" aria-hidden="true" tabindex="-1"></a>I'm sure it'll happen eventually!</span>
<span id="cb16-145"><a href="#cb16-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-146"><a href="#cb16-146" aria-hidden="true" tabindex="-1"></a><span class="fu"># Visualising the r/counting graph</span></span>
<span id="cb16-147"><a href="#cb16-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-148"><a href="#cb16-148" aria-hidden="true" tabindex="-1"></a>The above summary statistics are nice, but it would be even nicer if we could visualize the structure of the counting graph.</span>
<span id="cb16-149"><a href="#cb16-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-150"><a href="#cb16-150" aria-hidden="true" tabindex="-1"></a>That requires some way of placing nodes and edges in space, since a priori there is no spatial information in the graph.</span>
<span id="cb16-151"><a href="#cb16-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-152"><a href="#cb16-152" aria-hidden="true" tabindex="-1"></a>The nice creators of the <span class="co">[</span><span class="ot">gephi</span><span class="co">]()</span> software package have developed an excellent approach for this. The idea is that we can make nodes repel each other, and edges between nodes attract like springs, and then run the algorithm until the nodes find some equilibrium position. The result of this is that users with many total counts will be spread throughout the graph, and pairs of users who have counted a lot with each other will be relatively close</span>
<span id="cb16-153"><a href="#cb16-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-154"><a href="#cb16-154" aria-hidden="true" tabindex="-1"></a>When I do that on the counting graph, I get the structure seen on @fig-both</span>
<span id="cb16-155"><a href="#cb16-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-156"><a href="#cb16-156" aria-hidden="true" tabindex="-1"></a>:::{.column-page-inset}</span>
<span id="cb16-157"><a href="#cb16-157" aria-hidden="true" tabindex="-1"></a><span class="al">![The graph of the r/counting community, arranged according to the ForceAtlas 2 algorithm. The two colours are a partition of the graph into two communities](figures/both.svg)</span>{#fig-both}</span>
<span id="cb16-158"><a href="#cb16-158" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb16-159"><a href="#cb16-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-160"><a href="#cb16-160" aria-hidden="true" tabindex="-1"></a>The colour corresponds to which community a given node belongs to, when using the <span class="co">[</span><span class="ot">Louvain method for community detection</span><span class="co">](https://sourceforge.net/projects/louvain/)</span> and adjusting the parameters so that only two communities appear^<span class="co">[</span><span class="ot">This means that 2 probably isn't the best number for the total number of distinct communities in the graph; a higher number would probably be better. Instead, what it means is that if you have to assign one of two colours to each node, this is a good way of doing it.</span><span class="co">]</span>. This is a completely different approach to the one used to arrange the graph, so it's interesting to see that there is fairly good spatial separation between the two colours.</span>
<span id="cb16-161"><a href="#cb16-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-162"><a href="#cb16-162" aria-hidden="true" tabindex="-1"></a>:::: {.column-screen-inset#fig-colours}</span>
<span id="cb16-163"><a href="#cb16-163" aria-hidden="true" tabindex="-1"></a>::: {layout-nrow=1}</span>
<span id="cb16-164"><a href="#cb16-164" aria-hidden="true" tabindex="-1"></a><span class="al">![](figures/pink.svg)</span></span>
<span id="cb16-165"><a href="#cb16-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-166"><a href="#cb16-166" aria-hidden="true" tabindex="-1"></a><span class="al">![](figures/blue.svg)</span></span>
<span id="cb16-167"><a href="#cb16-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-168"><a href="#cb16-168" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb16-169"><a href="#cb16-169" aria-hidden="true" tabindex="-1"></a>The counters of respectively the pink and blue communities. The charts are vector graphics, so you should be able to view them in a separate tab and zoom in as much as you like.</span>
<span id="cb16-170"><a href="#cb16-170" aria-hidden="true" tabindex="-1"></a>::::</span>
<span id="cb16-171"><a href="#cb16-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-172"><a href="#cb16-172" aria-hidden="true" tabindex="-1"></a>We know the usernames of the counters in each community, and they are shown on @fig-colours. Looking at them, it seems that what it mainly picks up is the era when people were active, where pink is older users, and blue is newer ones. Certainly for my case I'm far more familiar with the green counters than with the pink, so it makes sense that I ended up on the blue team. It also makes sense that the top counters ended up more or less in the middle of the graph.</span>
<span id="cb16-173"><a href="#cb16-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-174"><a href="#cb16-174" aria-hidden="true" tabindex="-1"></a>I hope we can all wear these badges with pride and use them to hate on the other team <span class="sc">\#</span>goblues.</span>
<span id="cb16-175"><a href="#cb16-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-176"><a href="#cb16-176" aria-hidden="true" tabindex="-1"></a><span class="fu">## The core of the r/counting graph</span></span>
<span id="cb16-177"><a href="#cb16-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-178"><a href="#cb16-178" aria-hidden="true" tabindex="-1"></a>The counting community has evolved over time, with new people dropping in, and older counters fading away (and sometimes staging <span class="co">[</span><span class="ot">remarkable comebacks</span><span class="co">](index.qmd#tbl-oldest-counters)</span>).</span>
<span id="cb16-179"><a href="#cb16-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-180"><a href="#cb16-180" aria-hidden="true" tabindex="-1"></a>In the counting graph, one person is connected to another if they've ever replied to each another. The **degree** of a person is a count of how many connections they have. There's a really neat approach to finding the most connected group of people in the graph that goes as follows:</span>
<span id="cb16-181"><a href="#cb16-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-182"><a href="#cb16-182" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Define the connectivity score of the graph as the degree of the least-connected person in the graph</span>
<span id="cb16-183"><a href="#cb16-183" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Remove the least-connected person in the graph and see what happens to the connectivity score</span>
<span id="cb16-184"><a href="#cb16-184" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Keep going until the connectivity score starts to decrease.</span>
<span id="cb16-185"><a href="#cb16-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-186"><a href="#cb16-186" aria-hidden="true" tabindex="-1"></a>When you remove one person, you do to things that might affect the overall connectivity score:</span>
<span id="cb16-187"><a href="#cb16-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-188"><a href="#cb16-188" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>You remove the least-connected person, so in everyone that remains is at least as well connected as that person, and possibly more connected</span>
<span id="cb16-189"><a href="#cb16-189" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>You decrease the degree of everyone that was directly connected to the least-connected person, possibly causing the overall connectivity score to decrease.</span>
<span id="cb16-190"><a href="#cb16-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-191"><a href="#cb16-191" aria-hidden="true" tabindex="-1"></a>Doing that for the counting graph we get</span>
<span id="cb16-194"><a href="#cb16-194" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb16-195"><a href="#cb16-195" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> networkx.algorithms.core <span class="im">import</span> core_number</span>
<span id="cb16-196"><a href="#cb16-196" aria-hidden="true" tabindex="-1"></a>core <span class="op">=</span> core_number(G)</span>
<span id="cb16-197"><a href="#cb16-197" aria-hidden="true" tabindex="-1"></a>max_core <span class="op">=</span> <span class="bu">max</span>(core.values())</span>
<span id="cb16-198"><a href="#cb16-198" aria-hidden="true" tabindex="-1"></a>unweighted_core <span class="op">=</span> [key <span class="cf">for</span> key <span class="kw">in</span> core.keys() <span class="cf">if</span> core[key] <span class="op">==</span> <span class="bu">max</span>(core.values())]</span>
<span id="cb16-199"><a href="#cb16-199" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"There are </span><span class="sc">{</span><span class="bu">len</span>(unweighted_core)<span class="sc">}</span><span class="ss"> counters in the unweighted core."</span>)</span>
<span id="cb16-200"><a href="#cb16-200" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-201"><a href="#cb16-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-202"><a href="#cb16-202" aria-hidden="true" tabindex="-1"></a><span class="fu">### The weighted core</span></span>
<span id="cb16-203"><a href="#cb16-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-204"><a href="#cb16-204" aria-hidden="true" tabindex="-1"></a>The approach I've just described has an important flaw in that it completely ignores how often two counters have interacted, and only looks at whether they are connected. That means that the connection between two counters who have only one count together is given the same importance as the connection between the counters in @tbl-best-friends. That seems unfortunate.</span>
<span id="cb16-205"><a href="#cb16-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-206"><a href="#cb16-206" aria-hidden="true" tabindex="-1"></a>One way of proceeding would be to apply a threshold and only link two counters in the graph if they have counted together more than X times. That gets rid of the "One count is equivalent to arbitrarily many counts" issue, but isn't very satisfactory - instead, we get "X - 1 counts is equivalent to 0", and "X counts is equivalent to arbitrarily many".</span>
<span id="cb16-207"><a href="#cb16-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-208"><a href="#cb16-208" aria-hidden="true" tabindex="-1"></a>A better way would be if the strength of the connection could be incorporated into the calculation of the core. I'll spare you the details, but doing so is a bit tricky. When the network is unweighted, there is a fast algorithm for finding the core <span class="co">[</span><span class="ot">@batagelj2003om</span><span class="co">]</span>, but adding weights breaks that algorithm. I ended up implementing it myself, you can see the implementation <span class="co">[</span><span class="ot">here</span><span class="co">](https://github.com/cutonbuminband/rcounting/blob/main/rcounting/graph_tools.py#LL41)</span> if you want.</span>
<span id="cb16-209"><a href="#cb16-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-210"><a href="#cb16-210" aria-hidden="true" tabindex="-1"></a>Once I have a method for taking into account the weighted degree of each node, there are two questions to consider:</span>
<span id="cb16-211"><a href="#cb16-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-212"><a href="#cb16-212" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>How to model the strength of a single connection</span>
<span id="cb16-213"><a href="#cb16-213" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>How to model the total weight of a node, based on the strength of all the connections it has with other nodes</span>
<span id="cb16-214"><a href="#cb16-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-215"><a href="#cb16-215" aria-hidden="true" tabindex="-1"></a>The first question is absolutely vital to ask. If the strength of a connection between two counters is defined as just the total number of counts they have together, then no matter what else I do, the core ends up consisting of very few people who all have a lot of counts together. </span>
<span id="cb16-216"><a href="#cb16-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-219"><a href="#cb16-219" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb16-220"><a href="#cb16-220" aria-hidden="true" tabindex="-1"></a>coreness <span class="op">=</span> graph_tools.weighted_core_number(G, p<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb16-221"><a href="#cb16-221" aria-hidden="true" tabindex="-1"></a>max_core_value <span class="op">=</span> <span class="bu">max</span>(coreness.values())</span>
<span id="cb16-222"><a href="#cb16-222" aria-hidden="true" tabindex="-1"></a>unscaled_core <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> core <span class="cf">if</span> coreness[x] <span class="op">==</span> max_core_value]</span>
<span id="cb16-223"><a href="#cb16-223" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="ss">f"There are </span><span class="sc">{</span><span class="bu">len</span>(unscaled_core)<span class="sc">}</span><span class="ss"> counters in the core. They are:</span><span class="ch">\n\n</span><span class="ss"> - "</span> <span class="op">+</span> <span class="st">"</span><span class="ch">\n</span><span class="st">- "</span>.join(unscaled_core)</span>
<span id="cb16-224"><a href="#cb16-224" aria-hidden="true" tabindex="-1"></a>Markdown(s)</span>
<span id="cb16-225"><a href="#cb16-225" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-226"><a href="#cb16-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-227"><a href="#cb16-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-228"><a href="#cb16-228" aria-hidden="true" tabindex="-1"></a>A choice that works fairly well is to model the strength of the connection as the logarithm of the total number of counts. That lets more intense connections have more importance, but within reason.</span>
<span id="cb16-229"><a href="#cb16-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-230"><a href="#cb16-230" aria-hidden="true" tabindex="-1"></a>The second question is a bit more subtle, since there's an intuitive choice that works fairly well, namely just using the sum of all the connection strengths. But that's not the only way to do things. In the end I ended up taking a weighted combination of the degree of the node and the total connection strength, so that the weighted degree of node $i$, $k'_{i}$ is given by</span>
<span id="cb16-231"><a href="#cb16-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-232"><a href="#cb16-232" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-233"><a href="#cb16-233" aria-hidden="true" tabindex="-1"></a>k'_{i}= \left(k_{i}\right)^{1 - p} \left(\sum _{\textrm{neighbors} j}{w_{ij}}\right)^{p}</span>
<span id="cb16-234"><a href="#cb16-234" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-235"><a href="#cb16-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-236"><a href="#cb16-236" aria-hidden="true" tabindex="-1"></a>where the sum runs over all neighbors $j$ of node $i$, $w_{ij}$ is the strength of the connection between $i$ and $j$, and $p$ is a parameter I choose that varies between $0$ and $1$. Setting $p = 0$ means that only the unweighted degree of the node is considered, while setting $p = 1$ means that only the sum of connection strengths matters. In between, you get a mix.</span>
<span id="cb16-237"><a href="#cb16-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-240"><a href="#cb16-240" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb16-241"><a href="#cb16-241" aria-hidden="true" tabindex="-1"></a>graph_tools.scale_weights(G)</span>
<span id="cb16-242"><a href="#cb16-242" aria-hidden="true" tabindex="-1"></a>coreness <span class="op">=</span> graph_tools.weighted_core_number(G, p<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb16-243"><a href="#cb16-243" aria-hidden="true" tabindex="-1"></a>max_core_value <span class="op">=</span> <span class="bu">max</span>(coreness.values())</span>
<span id="cb16-244"><a href="#cb16-244" aria-hidden="true" tabindex="-1"></a>weighted_core <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> core <span class="cf">if</span> coreness[x] <span class="op">==</span> max_core_value]</span>
<span id="cb16-245"><a href="#cb16-245" aria-hidden="true" tabindex="-1"></a>nx.set_node_attributes(G, <span class="st">"periphery"</span>, name<span class="op">=</span><span class="st">"k-core"</span>)</span>
<span id="cb16-246"><a href="#cb16-246" aria-hidden="true" tabindex="-1"></a>nx.set_node_attributes(G.subgraph(weighted_core), <span class="st">"core"</span>, name<span class="op">=</span><span class="st">"k-core"</span>)</span>
<span id="cb16-247"><a href="#cb16-247" aria-hidden="true" tabindex="-1"></a>nx.write_gexf(G, <span class="st">"../data/graph.gexf"</span>)</span>
<span id="cb16-248"><a href="#cb16-248" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="ss">f"There are </span><span class="sc">{</span><span class="bu">len</span>(weighted_core)<span class="sc">}</span><span class="ss"> counters in the weighted core."</span></span>
<span id="cb16-249"><a href="#cb16-249" aria-hidden="true" tabindex="-1"></a>Markdown(s)</span>
<span id="cb16-250"><a href="#cb16-250" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-251"><a href="#cb16-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-252"><a href="#cb16-252" aria-hidden="true" tabindex="-1"></a>This is a slightly smaller number then counters who were in the core for the unweighted case, and there's also some difference in the composition of the members that remain:</span>
<span id="cb16-253"><a href="#cb16-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-256"><a href="#cb16-256" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb16-257"><a href="#cb16-257" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"There are </span><span class="sc">{</span><span class="bu">len</span>(<span class="bu">set</span>(weighted_core) <span class="op">^</span> <span class="bu">set</span>(unweighted_core))<span class="sc">}</span><span class="ss"> present in only one of the weighted or unweighted core."</span>)</span>
<span id="cb16-258"><a href="#cb16-258" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-259"><a href="#cb16-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-260"><a href="#cb16-260" aria-hidden="true" tabindex="-1"></a>With the core in hand, it's possible to visualise the counting graph again, this time highlighting the members of the weighted core, as shown on @fig-core</span>
<span id="cb16-261"><a href="#cb16-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-262"><a href="#cb16-262" aria-hidden="true" tabindex="-1"></a><span class="al">![The ~100 core members of the counting graph highlighted in green](figures/core.svg)</span>{#fig-core}</span>
<span id="cb16-263"><a href="#cb16-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-264"><a href="#cb16-264" aria-hidden="true" tabindex="-1"></a>Interestingly enough the core mainly seems to correspond to the blue team shown on @fig-both, so perhaps my earlier suggestion that the colours mainly correspond to age is incorrect.</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">
        <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="./about.html">About</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/cutonbuminband/rcounting">Github</a>
  </li>  
</ul>
      </div>
  </div>
</footer>



</body></html>